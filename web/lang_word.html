<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>lang word</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; line-height: 1.5; }
    main { max-width: 52rem; margin: 10vh auto; }
    a { text-decoration: none; border-bottom: 1px solid currentColor; }
    a:hover { opacity: .9; }

    .word { font-size: 2rem; margin: 0 0 .75rem; }
    .meta { opacity: .85; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; margin-bottom: 1.25rem; }
    .pill { border: 1px solid currentColor; border-radius: 999px; padding: .15rem .6rem; font-size: .9rem; }

    .panel { border: 1px solid color-mix(in oklab, currentColor 40%, transparent); border-radius: 1rem; padding: 1rem; margin-top: 1rem; }
    .panel h2 { font-size: 1rem; margin: 0 0 .75rem; }

    .row { display:flex; gap:.5rem; align-items:center; margin:.5rem 0; }
    input[type="text"], select, textarea {
      width: 100%; padding: .5rem .6rem; border-radius: .5rem;
      border: 1px solid currentColor; background: transparent; color: inherit;
    }
    textarea { resize: vertical; }
    button {
      border: 1px solid currentColor; background: transparent; color: inherit;
      border-radius: .6rem; padding: .45rem .7rem; cursor: pointer;
      white-space: nowrap;
    }
    button:focus, input:focus, select:focus { outline: 2px solid currentColor; outline-offset: 2px; }
    .muted { opacity: .75; }

    .version-head { display:flex; gap:.5rem; align-items:center; justify-content:space-between; }
    .version-title { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }

    ul { padding-left: 1.25rem; margin: .5rem 0 0; }
    li { margin: .35rem 0; }

    .child-edit-row { display:flex; flex-direction: column; gap:.35rem; margin:.55rem 0; padding: .45rem; border-radius: .75rem; border: 1px solid color-mix(in oklab, currentColor 25%, transparent); }
    .child-edit-row .line { display:flex; gap:.5rem; align-items:center; }
    .child-edit-row input { flex: 1; }

    /* Side panel (exchange) */
    #overlay {
      position: fixed;
      inset: 0;
      background: color-mix(in oklab, Canvas 70%, transparent);
      backdrop-filter: blur(2px);
      display: none;
      z-index: 50;
    }
    #sidepanel {
      position: fixed;
      top: 0;
      right: 0;
      height: 100%;
      width: min(560px, 94vw);
      background: Canvas;
      border-left: 1px solid color-mix(in oklab, currentColor 40%, transparent);
      box-shadow: 0 0 30px color-mix(in oklab, currentColor 20%, transparent);
      transform: translateX(100%);
      transition: transform 180ms ease;
      z-index: 51;
      display: flex;
      flex-direction: column;
    }
    #sidepanel.open { transform: translateX(0); }
    #sidepanel header {
      padding: 1rem;
      border-bottom: 1px solid color-mix(in oklab, currentColor 40%, transparent);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: .75rem;
    }
    #sidepanel header strong { font-size: 1rem; }
    #sidepanel .content { padding: 1rem; overflow: auto; }

    .cols {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: .75rem;
      align-items: start;
      margin-top: .75rem;
    }
    .kidbtn { width: 100%; text-align: left; }
    .kidbtn.selected { border-width: 2px; }
    .danger {
      border-color: color-mix(in oklab, red 45%, transparent) !important;
    }

  </style>
</head>
<body>
  <main>
    <p><a href="./">← back</a></p>

    <h1 class="word" id="word">…</h1>

    <div class="meta">
      <span class="pill" id="lang-pill">lang_word …</span>
      <span class="pill" id="ver-pill">version …</span>
      <span class="pill" id="mode-pill">view</span>
      <button id="admin-btn" type="button">enter admin key</button>
      <button id="clear-admin-btn" type="button" style="display:none;">clear key</button>

      <button id="exchange-open" type="button" style="display:none;">exchange</button>
      <button id="delete-word" type="button" style="display:none;">delete word</button>

    </div>

    <section class="panel">
      <h2>versions</h2>

      <div id="edit-top" style="display:none;">
        <div class="row">
          <button id="create-version" type="button">create new version</button>
          <span class="muted" id="create-version-msg"></span>
        </div>

        <div class="row">
          <select id="add-to-version"></select>
        </div>

        <div class="row">
          <input id="new-child" type="text" placeholder="new child word (⌘/Ctrl + Enter)" />
        </div>
        <div class="row">
          <input id="new-child-link" type="text" placeholder="optional link (opens in new tab)" />
          <button id="add-child" type="button">add</button>
        </div>

        <div class="row">
          <textarea id="bulk-children" rows="7" placeholder="bulk child words (one per line)"></textarea>
        </div>
        <div class="row">
          <button id="add-children-bulk" type="button">bulk add</button>
          <span class="muted" id="bulk-add-msg"></span>
        </div>
      </div>

      <div id="versions-container"></div>
      <p id="empty" class="muted" style="display:none;">no versions found.</p>
    </section>
  </main>

  <!-- Sidepanel + overlay -->
  <div id="overlay" aria-hidden="true"></div>
  <aside id="sidepanel" aria-label="exchange panel">
    <header>
      <strong>exchange child words</strong>
      <button id="exchange-close" type="button">close</button>
    </header>
    <div class="content">
      <p class="muted" style="margin-top:0;">
        Move child words between the <strong>current version</strong> (left) and a <strong>selected</strong> word/version (right).
      </p>

      <div class="panel" style="margin-top:0;">
        <h2>select existing</h2>
        <div class="row">
          <select id="existing-words"></select>
          <button id="load-existing" type="button">load</button>
          <button id="open-selected" type="button">open</button>
        </div>
        <div class="row">
          <select id="existing-versions"></select>
        </div>
        <div class="row muted" id="selected-status"></div>
      </div>

      <div class="panel">
        <h2>or create new parent</h2>
        <div class="row">
          <input id="new-parent-word" type="text" placeholder="new parent lang word" />
          <button id="create-parent" type="button">create</button>
        </div>
        <div class="row muted" id="create-status"></div>
      </div>

      <div class="cols">
        <div>
          <div class="muted" style="margin-bottom:.25rem;">current (this version)</div>
          <div id="left-kids"></div>
        </div>

        <div style="display:flex; flex-direction:column; gap:.5rem; margin-top:1.5rem;">
          <button id="to-right" type="button">→</button>
          <button id="to-left" type="button">←</button>
        </div>

        <div>
          <div class="muted" style="margin-bottom:.25rem;">selected (right)</div>
          <div id="right-kids"></div>
        </div>
      </div>
    </div>
  </aside>

  <script>
    const ADMIN_KEY_STORAGE = "lang_admin_key";

    const params = new URLSearchParams(location.search);
    const versionIdParam = params.get("id"); // this is a VERSION id

    const wordEl = document.getElementById("word");
    const langPill = document.getElementById("lang-pill");
    const verPill = document.getElementById("ver-pill");
    const modePill = document.getElementById("mode-pill");

    const adminBtn = document.getElementById("admin-btn");
    const clearAdminBtn = document.getElementById("clear-admin-btn");

    const editTop = document.getElementById("edit-top");
    const createVersionBtn = document.getElementById("create-version");
    const createVersionMsg = document.getElementById("create-version-msg");

    const addToVersionSelect = document.getElementById("add-to-version");
    const newChildInput = document.getElementById("new-child");
    const newChildLinkInput = document.getElementById("new-child-link");
    const addChildBtn = document.getElementById("add-child");

    const bulkChildrenTextarea = document.getElementById("bulk-children");
    const bulkAddBtn = document.getElementById("add-children-bulk");
    const bulkAddMsg = document.getElementById("bulk-add-msg");

    const versionsContainer = document.getElementById("versions-container");
    const emptyEl = document.getElementById("empty");

    // Exchange UI elements
    const exchangeOpenBtn = document.getElementById("exchange-open");
    const deleteWordBtn = document.getElementById("delete-word");
    const overlay = document.getElementById("overlay");
    const sidepanel = document.getElementById("sidepanel");
    const exchangeCloseBtn = document.getElementById("exchange-close");

    const existingWordsSelect = document.getElementById("existing-words");
    const loadExistingBtn = document.getElementById("load-existing");
    const openSelectedBtn = document.getElementById("open-selected");
    const existingVersionsSelect = document.getElementById("existing-versions");
    const selectedStatus = document.getElementById("selected-status");

    const newParentInput = document.getElementById("new-parent-word");
    const createParentBtn = document.getElementById("create-parent");
    const createStatus = document.getElementById("create-status");

    const leftKids = document.getElementById("left-kids");
    const rightKids = document.getElementById("right-kids");
    const toRightBtn = document.getElementById("to-right");
    const toLeftBtn = document.getElementById("to-left");

    let adminVerified = false;
    let currentData = null; // payload from GET /api/lang_words/<version_id>

    // exchange state (right side)
    let rightData = null;     // payload from GET /api/lang_words/<rightSelectedVersionId>
    let rightVersionId = null;

    let selectedLeftChildId = null;
    let selectedRightChildId = null;

    function getAdminKey() {
      return localStorage.getItem(ADMIN_KEY_STORAGE) || "";
    }
    function setAdminKey(key) {
      localStorage.setItem(ADMIN_KEY_STORAGE, key);
    }
    function clearAdminKey() {
      localStorage.removeItem(ADMIN_KEY_STORAGE);
    }
    function isEditMode() {
      return adminVerified;
    }

    async function verifyAdminKey() {
      const key = getAdminKey();
      if (!key) { adminVerified = false; return false; }

      const res = await fetch("/api/admin/ping", {
        headers: { "Accept": "application/json", "X-Admin-Key": key }
      });

      if (res.ok) { adminVerified = true; return true; }

      clearAdminKey();
      adminVerified = false;
      return false;
    }

    function setModeUI() {
      const edit = isEditMode();
      modePill.textContent = edit ? "edit" : "view";
      editTop.style.display = edit ? "" : "none";
      clearAdminBtn.style.display = edit ? "" : "none";
      adminBtn.textContent = edit ? "admin verified" : "enter admin key";
      adminBtn.disabled = edit;

      exchangeOpenBtn.style.display = edit ? "" : "none";
      deleteWordBtn.style.display = edit ? "" : "none";
      deleteWordBtn.classList.toggle("danger", edit);

    }

    async function apiFetch(url, opts = {}) {
      const res = await fetch(url, opts);
      if (res.status === 401) {
        clearAdminKey();
        adminVerified = false;
        setModeUI();
        closeExchangePanel();
      }
      return res;
    }

    function openExchangePanel() {
      overlay.style.display = "block";
      sidepanel.classList.add("open");
    }
    function closeExchangePanel() {
      overlay.style.display = "none";
      sidepanel.classList.remove("open");

      selectedStatus.textContent = "";
      createStatus.textContent = "";

      rightData = null;
      rightVersionId = null;

      selectedLeftChildId = null;
      selectedRightChildId = null;

      leftKids.innerHTML = "";
      rightKids.innerHTML = "";
    }

    async function loadWordAndVersions(versionId) {
      const res = await apiFetch(`/api/lang_words/${encodeURIComponent(versionId)}`, {
        headers: { "Accept": "application/json" }
      });
      if (!res.ok) return null;
      return res.json();
    }

    async function loadCurrent() {
      if (!versionIdParam) {
        wordEl.textContent = "missing version id";
        verPill.textContent = "version ?";
        langPill.textContent = "lang_word ?";
        return null;
      }

      const data = await loadWordAndVersions(versionIdParam);
      if (!data) {
        wordEl.textContent = "word/version not found";
        return null;
      }

      currentData = data;

      wordEl.textContent = data.word;
      document.title = data.word;

      langPill.textContent = `lang_word ${data.lang_word_id}`;
      verPill.textContent = `version ${data.current_version} (id ${data.current_version_id})`;

      renderVersions(data);
      return data;
    }

    function openVersion(versionId) {
      window.location.href = `lang_word.html?id=${encodeURIComponent(versionId)}`;
    }

    function renderChildWordViewItem(c) {
      // View mode: if link exists, make it clickable and open in new tab
      if (c.link && String(c.link).trim()) {
        const a = document.createElement("a");
        a.href = c.link;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = c.word;
        return a;
      }
      return document.createTextNode(c.word);
    }

    function renderVersions(data) {
      const versions = Array.isArray(data.versions) ? data.versions : [];
      versionsContainer.innerHTML = "";
      emptyEl.style.display = versions.length ? "none" : "";

      // Populate add-to-version select (edit mode)
      addToVersionSelect.innerHTML = "";
      for (const v of versions) {
        const opt = document.createElement("option");
        opt.value = String(v.version_id);
        opt.textContent = `Version ${v.version} (id ${v.version_id})`;
        if (v.version_id === data.current_version_id) opt.selected = true;
        addToVersionSelect.appendChild(opt);
      }

      for (const v of versions) {
        const panel = document.createElement("div");
        panel.className = "panel";

        const head = document.createElement("div");
        head.className = "version-head";

        const left = document.createElement("div");
        left.className = "version-title";

        const title = document.createElement("strong");
        title.textContent = `Version ${v.version}`;

        const idP = document.createElement("span");
        idP.className = "pill";
        idP.textContent = `id ${v.version_id}`;

        left.appendChild(title);
        left.appendChild(idP);

        const right = document.createElement("div");
        const openBtn = document.createElement("button");
        openBtn.type = "button";
        openBtn.textContent = (v.version_id === data.current_version_id) ? "current" : "open";
        openBtn.disabled = (v.version_id === data.current_version_id);
        openBtn.addEventListener("click", () => openVersion(v.version_id));
        right.appendChild(openBtn);

        if (isEditMode()) {
          const delVerBtn = document.createElement("button");
          delVerBtn.type = "button";
          delVerBtn.textContent = "delete version";
          delVerBtn.className = "danger";

          delVerBtn.addEventListener("click", async () => {
            const msg =
              `DELETE Version ${v.version} (id ${v.version_id})?\n\n` +
              `This deletes all child words in this version.`;
            if (!confirm(msg)) return;

            const key = getAdminKey();

            // Choose a fallback version to open if we delete the currently-open version
            const fallback = versions
              .filter(x => x.version_id !== v.version_id)
              .sort((a, b) => (b.version - a.version))[0];

            const r = await apiFetch(`/api/lang_word_versions/${encodeURIComponent(v.version_id)}`, {
              method: "DELETE",
              headers: { "Accept": "application/json", "X-Admin-Key": key }
            });

            if (!r.ok) {
              const err = await r.json().catch(() => ({}));
              alert(err.error || `delete failed (${r.status})`);
              return;
            }

            // If we deleted the currently open version, navigate to another version
            if (currentData && v.version_id === currentData.current_version_id) {
              if (fallback && fallback.version_id) {
                openVersion(fallback.version_id);
              } else {
                // Shouldn't happen unless backend allows deleting last version
                window.location.href = "./";
              }
              return;
            }

            await refresh();
          });

          right.appendChild(delVerBtn);
        }


        head.appendChild(left);
        head.appendChild(right);
        panel.appendChild(head);

        const kids = Array.isArray(v.child_words) ? v.child_words : [];
        if (!kids.length) {
          const p = document.createElement("p");
          p.className = "muted";
          p.style.margin = ".5rem 0 0";
          p.textContent = "no child words.";
          panel.appendChild(p);
        } else {
          const ul = document.createElement("ul");
          for (const c of kids) {
            const li = document.createElement("li");
            li.appendChild(renderChildWordViewItem(c));
            ul.appendChild(li);
          }
          panel.appendChild(ul);
        }

        if (isEditMode()) {
          const editWrap = document.createElement("div");
          editWrap.style.marginTop = ".75rem";

          const label = document.createElement("div");
          label.className = "muted";
          label.textContent = "edit child words (this version)";
          editWrap.appendChild(label);

          for (const c of kids) {
            const row = document.createElement("div");
            row.className = "child-edit-row";

            const line1 = document.createElement("div");
            line1.className = "line";

            const inputWord = document.createElement("input");
            inputWord.type = "text";
            inputWord.value = c.word;

            const save = document.createElement("button");
            save.type = "button";
            save.textContent = "save";

            const del = document.createElement("button");
            del.type = "button";
            del.textContent = "delete";

            line1.appendChild(inputWord);
            line1.appendChild(save);
            line1.appendChild(del);

            const line2 = document.createElement("div");
            line2.className = "line";

            const inputLink = document.createElement("input");
            inputLink.type = "text";
            inputLink.placeholder = "optional link (opens in new tab)";
            inputLink.value = c.link || "";

            line2.appendChild(inputLink);

            save.addEventListener("click", async () => {
              const nextWord = inputWord.value.trim();
              const nextLink = inputLink.value.trim();
              if (!nextWord) return;

              const key = getAdminKey();
              const r = await apiFetch(`/api/child_words/${c.id}`, {
                method: "PUT",
                headers: {
                  "Content-Type": "application/json",
                  "Accept": "application/json",
                  "X-Admin-Key": key
                },
                body: JSON.stringify({ word: nextWord, link: nextLink })
              });

              if (!r.ok) {
                const err = await r.json().catch(() => ({}));
                alert(err.error || `save failed (${r.status})`);
                return;
              }
              await refresh();
            });

            del.addEventListener("click", async () => {
              if (!confirm("delete this child word?")) return;

              const key = getAdminKey();
              const r = await apiFetch(`/api/child_words/${c.id}`, {
                method: "DELETE",
                headers: { "Accept": "application/json", "X-Admin-Key": key }
              });

              if (!r.ok) {
                const err = await r.json().catch(() => ({}));
                alert(err.error || `delete failed (${r.status})`);
                return;
              }
              await refresh();
            });

            row.appendChild(line1);
            row.appendChild(line2);
            editWrap.appendChild(row);
          }

          panel.appendChild(editWrap);
        }

        versionsContainer.appendChild(panel);
      }
    }

    async function refresh() {
      await loadCurrent();
      setModeUI();
      if (currentData) renderVersions(currentData);

      // If exchange open, refresh sides
      if (sidepanel.classList.contains("open")) {
        await refreshExchangeSides();
      }
    }

    // Create new version (admin)
    createVersionBtn.addEventListener("click", async () => {
      if (!currentData) return;
      const key = getAdminKey();
      if (!key) return;

      createVersionMsg.textContent = "";

      const r = await apiFetch(`/api/lang_words/${currentData.lang_word_id}/versions`, {
        method: "POST",
        headers: { "Accept": "application/json", "X-Admin-Key": key }
      });

      if (!r.ok) {
        const err = await r.json().catch(() => ({}));
        createVersionMsg.textContent = err.error || `create failed (${r.status})`;
        return;
      }

      const out = await r.json();
      createVersionMsg.textContent = `created version ${out.version} (id ${out.version_id})`;
      openVersion(out.version_id);
    });

    // Add child to selected version (now supports optional link)
    addChildBtn.addEventListener("click", async () => {
      if (!isEditMode()) return;
      const key = getAdminKey();
      if (!key) return;

      const word = newChildInput.value.trim();
      const link = newChildLinkInput.value.trim();
      if (!word) return;

      const versionId = Number(addToVersionSelect.value);
      if (!Number.isInteger(versionId) || versionId <= 0) return;

      const r = await apiFetch(`/api/lang_word_versions/${encodeURIComponent(versionId)}/child_words`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-Admin-Key": key
        },
        body: JSON.stringify({ word, link })
      });

      if (!r.ok) {
        const err = await r.json().catch(() => ({}));
        alert(err.error || `add failed (${r.status})`);
        return;
      }

      newChildInput.value = "";
      newChildLinkInput.value = "";
      await refresh();
    });

    // Bulk add children
    bulkAddBtn.addEventListener("click", async () => {
      bulkAddMsg.textContent = "";
      if (!isEditMode()) return;

      const key = getAdminKey();
      if (!key) return;

      const versionId = Number(addToVersionSelect.value);
      if (!Number.isInteger(versionId) || versionId <= 0) return;

      // Parse lines => words
      const raw = bulkChildrenTextarea.value || "";
      const lines = raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

      // optional: de-dupe while preserving order
      const seen = new Set();
      const words = [];
      for (const w of lines) {
        if (!seen.has(w)) {
          seen.add(w);
          words.push(w);
        }
      }

      if (!words.length) return;

      // Bulk adds always insert without links
      const link = "";

      bulkAddBtn.disabled = true;
      let okCount = 0;
      const failures = [];

      try {
        for (let i = 0; i < words.length; i++) {
          const word = words[i];

          bulkAddMsg.textContent = `adding ${i + 1}/${words.length}…`;

          const r = await apiFetch(`/api/lang_word_versions/${encodeURIComponent(versionId)}/child_words`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Accept": "application/json",
              "X-Admin-Key": key
            },
            body: JSON.stringify({ word, link })
          });

          if (!r.ok) {
            const err = await r.json().catch(() => ({}));
            failures.push({ word, error: err.error || `HTTP ${r.status}` });
            continue;
          }
          okCount++;
        }

        if (failures.length) {
          bulkAddMsg.textContent = `added ${okCount}/${words.length}. ${failures.length} failed (see console).`;
          console.warn("Bulk add failures:", failures);
        } else {
          bulkAddMsg.textContent = `added ${okCount} word(s).`;
          bulkChildrenTextarea.value = "";
        }

        await refresh();
      } finally {
        bulkAddBtn.disabled = false;
      }
    });

    // Cmd/Ctrl+Enter in add-child input triggers add
    newChildInput.addEventListener("keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
        e.preventDefault();
        addChildBtn.click();
      }
    });

    // Cmd/Ctrl+Enter in bulk textarea triggers bulk add
    bulkChildrenTextarea.addEventListener("keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
        e.preventDefault();
        bulkAddBtn.click();
      }
    });

    // Admin buttons
    adminBtn.addEventListener("click", async () => {
      const key = prompt("Admin key (stored locally):", getAdminKey() || "");
      if (!key || !key.trim()) return;

      setAdminKey(key.trim());
      const ok = await verifyAdminKey();
      setModeUI();
      await refresh();

      if (!ok) alert("Admin key invalid.");
    });

    clearAdminBtn.addEventListener("click", async () => {
      clearAdminKey();
      adminVerified = false;
      setModeUI();
      closeExchangePanel();
      await refresh();
    });

    // ========= Exchange Panel Logic (unchanged aside from reading kids with link present) =========

    exchangeOpenBtn.addEventListener("click", async () => {
      if (!isEditMode()) return;
      if (!currentData) await loadCurrent();
      openExchangePanel();
      await initExistingWordsSelect();
      await refreshExchangeSides();
    });

    overlay.addEventListener("click", () => closeExchangePanel());
    exchangeCloseBtn.addEventListener("click", () => closeExchangePanel());

    async function initExistingWordsSelect() {
      existingWordsSelect.innerHTML = "";
      existingVersionsSelect.innerHTML = "";
      selectedStatus.textContent = "";

      const res = await apiFetch(`/api/lang_words`, { headers: { "Accept": "application/json" } });
      if (!res.ok) {
        selectedStatus.textContent = "failed to load words.";
        return;
      }
      const data = await res.json().catch(() => ({}));
      const words = Array.isArray(data.words) ? data.words : [];

      for (const w of words) {
        const opt = document.createElement("option");
        opt.value = String(w.version_id);
        opt.textContent = `${w.word} (latest v${w.version}, id ${w.version_id})`;
        existingWordsSelect.appendChild(opt);
      }

      const curVid = Number(currentData?.current_version_id);
      const alt = words.find(x => x.version_id !== curVid);
      if (alt) existingWordsSelect.value = String(alt.version_id);
    }

    async function loadRightByVersionId(versionId) {
      rightVersionId = Number(versionId);
      if (!Number.isInteger(rightVersionId) || rightVersionId <= 0) return false;

      const d = await loadWordAndVersions(rightVersionId);
      if (!d) {
        rightData = null;
        existingVersionsSelect.innerHTML = "";
        selectedStatus.textContent = "selected word/version not found.";
        renderExchangeLists();
        return false;
      }

      rightData = d;
      selectedStatus.textContent = `selected: "${d.word}" (lang_word ${d.lang_word_id})`;

      existingVersionsSelect.innerHTML = "";
      for (const v of (d.versions || [])) {
        const opt = document.createElement("option");
        opt.value = String(v.version_id);
        opt.textContent = `Version ${v.version} (id ${v.version_id})`;
        if (v.version_id === rightVersionId) opt.selected = true;
        existingVersionsSelect.appendChild(opt);
      }

      renderExchangeLists();
      return true;
    }

    loadExistingBtn.addEventListener("click", async () => {
      const vid = existingWordsSelect.value;
      await loadRightByVersionId(vid);
      existingVersionsSelect.value = String(rightVersionId);
    });

    existingVersionsSelect.addEventListener("change", async () => {
      const vid = existingVersionsSelect.value;
      await loadRightByVersionId(vid);
    });

    openSelectedBtn.addEventListener("click", () => {
      if (!rightVersionId) return;
      openVersion(rightVersionId);
    });

    createParentBtn.addEventListener("click", async () => {
      if (!isEditMode()) return;
      const key = getAdminKey();
      if (!key) return;

      const w = newParentInput.value.trim();
      if (!w) return;

      createStatus.textContent = "";

      const r = await apiFetch(`/api/lang_words`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-Admin-Key": key
        },
        body: JSON.stringify({ word: w })
      });

      if (!r.ok) {
        const err = await r.json().catch(() => ({}));
        createStatus.textContent = err.error || `create failed (${r.status})`;
        return;
      }

      const out = await r.json();
      newParentInput.value = "";
      createStatus.textContent = `created "${out.word}" (version id ${out.version_id}).`;

      await loadRightByVersionId(out.version_id);

      await initExistingWordsSelect();
      existingWordsSelect.value = String(out.version_id);
      existingVersionsSelect.value = String(out.version_id);
    });

    newParentInput.addEventListener("keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
        e.preventDefault();
        createParentBtn.click();
      }
    });

    deleteWordBtn.addEventListener("click", async () => {
      if (!isEditMode() || !currentData) return;

      const msg =
        `DELETE lang_word "${currentData.word}" (id ${currentData.lang_word_id})?\n\n` +
        `This will delete ALL versions and ALL child words.`;
      if (!confirm(msg)) return;

      const key = getAdminKey();
      const r = await apiFetch(`/api/lang_words/${encodeURIComponent(currentData.lang_word_id)}`, {
        method: "DELETE",
        headers: { "Accept": "application/json", "X-Admin-Key": key }
      });

      if (!r.ok) {
        const err = await r.json().catch(() => ({}));
        alert(err.error || `delete failed (${r.status})`);
        return;
      }

      // back to home
      window.location.href = "./";
    });


    function getCurrentVersionChildren() {
      if (!currentData) return [];
      const v = (currentData.versions || []).find(x => x.version_id === currentData.current_version_id);
      return v?.child_words || [];
    }

    function getRightVersionChildren() {
      if (!rightData || !rightVersionId) return [];
      const v = (rightData.versions || []).find(x => x.version_id === rightVersionId);
      return v?.child_words || [];
    }

    function renderKidsList(container, kids, side) {
      container.innerHTML = "";
      if (!kids.length) {
        const p = document.createElement("p");
        p.className = "muted";
        p.style.margin = "0";
        p.textContent = "no child words.";
        container.appendChild(p);
        return;
      }

      kids.forEach((c) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "kidbtn";
        btn.textContent = c.word;

        const selected =
          (side === "left" && c.id === selectedLeftChildId) ||
          (side === "right" && c.id === selectedRightChildId);
        if (selected) btn.classList.add("selected");

        btn.addEventListener("click", () => {
          if (side === "left") {
            selectedLeftChildId = c.id;
            selectedRightChildId = null;
          } else {
            selectedRightChildId = c.id;
            selectedLeftChildId = null;
          }
          renderExchangeLists();
        });

        container.appendChild(btn);
      });
    }

    function renderExchangeLists() {
      renderKidsList(leftKids, getCurrentVersionChildren(), "left");

      if (!rightVersionId) {
        rightKids.innerHTML = "";
        const p = document.createElement("p");
        p.className = "muted";
        p.style.margin = "0";
        p.textContent = "select or create a word to exchange with.";
        rightKids.appendChild(p);
      } else {
        renderKidsList(rightKids, getRightVersionChildren(), "right");
      }
    }

    async function refreshExchangeSides() {
      await loadCurrent();

      if (rightVersionId) {
        await loadRightByVersionId(rightVersionId);
      } else {
        renderExchangeLists();
      }

      selectedLeftChildId = null;
      selectedRightChildId = null;
      renderExchangeLists();
    }

    async function moveChild(childId, targetVersionId) {
      const key = getAdminKey();
      const r = await apiFetch(`/api/child_words/${childId}/move`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-Admin-Key": key
        },
        body: JSON.stringify({ lang_word_version_id: targetVersionId })
      });

      if (!r.ok) {
        const err = await r.json().catch(() => ({}));
        alert(err.error || `move failed (${r.status})`);
        return false;
      }
      return true;
    }

    toRightBtn.addEventListener("click", async () => {
      if (!rightVersionId) return;
      if (!selectedLeftChildId) return;

      const ok = await moveChild(selectedLeftChildId, rightVersionId);
      if (!ok) return;

      await refreshExchangeSides();
    });

    toLeftBtn.addEventListener("click", async () => {
      if (!rightVersionId) return;
      if (!selectedRightChildId) return;

      const ok = await moveChild(selectedRightChildId, currentData.current_version_id);
      if (!ok) return;

      await refreshExchangeSides();
    });

    // boot
    (async () => {
      await verifyAdminKey();
      setModeUI();
      await loadCurrent();
    })();
  </script>
</body>
</html>
