<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>fantasiagenesis</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; line-height: 1.5; }
    main { max-width: 42rem; margin: 10vh auto; text-align: center; }
    h1 { font-size: 1.25rem; margin: 0 0 1rem; }
    p { margin: 0 0 1.25rem; }
    nav a { display: inline-block; margin: .25rem .5rem; text-decoration: none; padding: .5rem .75rem; border-radius: .5rem; border: 1px solid currentColor; }
    nav a:focus { outline: 2px solid currentColor; outline-offset: 2px; }
    .media-row { display: flex; gap: 1rem; align-items: stretch; justify-content: center; }
    .media-row img,
    .media-row video { width: 100%; max-width: 14rem; height: auto; object-fit: cover; border-radius: .25rem; }
    @media (max-width: 720px) {
      .media-row { flex-direction: column; }
      .media-row img,
      .media-row video { max-width: 100%; }
    }

    #word-layer {
      position: fixed;
      inset: 0;
      pointer-events: none; /* words don't block clicks */
      z-index: 0; /* set to 9999 if you want them ABOVE everything */
      overflow: hidden;
    }

    .thought {
      position: absolute;
      left: 0;
      top: 0;
      transform: translate3d(0,0,0);
      padding: .25rem .5rem;
      border-radius: .75rem;
      border: 1px solid color-mix(in oklab, currentColor 70%, transparent);
      background: color-mix(in oklab, Canvas 85%, transparent);
      backdrop-filter: blur(4px);
      font-size: .95rem;
      white-space: nowrap;
      opacity: .85;
      will-change: transform;
      user-select: none;
    }

    /* Keep your main above if words are behind */
    main { position: relative; z-index: 1; }

    @media (prefers-reduced-motion: reduce) {
      .thought { transition: none !important; }
    }

    /* Buttons bottom-right */
    #add-word-btn,
    #list-toggle-btn {
      position: fixed;
      bottom: 1.25rem;
      z-index: 2; /* above main + words layer */
      border: 1px solid currentColor;
      background: color-mix(in oklab, Canvas 85%, transparent);
      backdrop-filter: blur(6px);
      border-radius: 999px;
      padding: .6rem .9rem;
      cursor: pointer;
      font-size: 1rem;
      line-height: 1;
    }
    #add-word-btn { right: 1.25rem; }
    #list-toggle-btn { right: 4.25rem; } /* sits left of + */

    #add-word-btn:focus,
    #list-toggle-btn:focus { outline: 2px solid currentColor; outline-offset: 2px; }

    /* Static list panel */
    #word-list {
      position: fixed;
      top: 1.25rem;
      left: 1.25rem;
      right: 1.25rem;
      max-width: 56rem;
      margin: 0 auto;
      z-index: 3;
      display: none;
      border: 1px solid color-mix(in oklab, currentColor 40%, transparent);
      border-radius: 1rem;
      background: color-mix(in oklab, Canvas 92%, transparent);
      backdrop-filter: blur(6px);
      padding: 1rem;
      box-shadow: 0 0 30px color-mix(in oklab, currentColor 15%, transparent);
    }
    #word-list h2 {
      margin: 0 0 .75rem;
      font-size: 1rem;
      font-weight: 600;
      text-align: left;
    }
    #word-list .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(11rem, 1fr));
      gap: .5rem .75rem;
      text-align: left;
    }
    #word-list a {
      display: inline-block;
      text-decoration: none;
      padding: .45rem .6rem;
      border-radius: .6rem;
      border: 1px solid color-mix(in oklab, currentColor 35%, transparent);
    }
    #word-list a:focus { outline: 2px solid currentColor; outline-offset: 2px; }
    #word-list .muted { opacity: .75; font-size: .9rem; margin-top: .5rem; text-align: left; }

    /* When list is visible, stop animation words from showing/clicking */
    body.list-mode #word-layer { display: none; }
  </style>
</head>
<body>
  <div id="word-layer" aria-hidden="true"></div>

  <!-- Static list container -->
  <section id="word-list" aria-label="Lang word list">
    <h2>words</h2>
    <div class="grid" id="word-list-grid"></div>
    <div class="muted" id="word-list-meta"></div>
  </section>

  <button id="list-toggle-btn" type="button" aria-label="Toggle word list">☰</button>
  <button id="add-word-btn" type="button" aria-label="Add lang word">＋</button>

  <main>
    <p><a href="https://github.com/b0risfosso/lang" target="_blank" rel="noopener noreferrer">lang</a></p>
    <div class="media-row">
      <img
        src="Michelangelo_-_Creation_of_Adam_(cropped)-2.jpg"
        alt="Michelangelo, The Creation of Adam (cropped)"
        loading="lazy"
      />
      <video controls autoplay loop muted playsinline preload="metadata">
        <source src="YTDown.com_YouTube_I-think-I-can-I-think-I-can-the-Little-E_Media_Yx9xO98kcBU_001_360p.mp4" type="video/mp4" />
        Sorry, your browser does not support embedded videos.
      </video>
      <video controls autoplay loop muted playsinline preload="metadata">
        <source src="YTDown.com_YouTube_Interstellar-Gargantua-Detach-Scene-1080_Media__GdEsdEfZvc_001_720p.mp4" type="video/mp4" />
        Sorry, your browser does not support embedded videos.
      </video>
    </div>
  </main>

  <script>
    // ==== CONFIG ====
    const AVOID_MAIN = true;
    const API_BASE = ""; // same origin; set if your API is elsewhere
    const ADMIN_KEY_STORAGE = "lang_admin_key";

    // ==== IMPLEMENTATION ====
    const layer = document.getElementById("word-layer");
    const mainEl = document.querySelector("main");
    const addBtn = document.getElementById("add-word-btn");
    const listToggleBtn = document.getElementById("list-toggle-btn");
    const listPanel = document.getElementById("word-list");
    const listGrid = document.getElementById("word-list-grid");
    const listMeta = document.getElementById("word-list-meta");

    const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const rand = (min, max) => Math.random() * (max - min) + min;

    let cachedWords = [];
    let listMode = false;

    // Track cursor for "react" behavior
    const mouse = { x: null, y: null };
    window.addEventListener("pointermove", (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    }, { passive: true });

    function getAvoidRect() {
      if (!AVOID_MAIN || !mainEl) return null;
      const r = mainEl.getBoundingClientRect();
      const pad = 24;
      return { left: r.left - pad, top: r.top - pad, right: r.right + pad, bottom: r.bottom + pad };
    }

    function pointOutsideRect(x, y, rect) {
      if (!rect) return true;
      return (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom);
    }

    function pickTarget(el) {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rect = getAvoidRect();

      const b = el.getBoundingClientRect();
      const w = b.width || 80;
      const h = b.height || 24;

      for (let i = 0; i < 25; i++) {
        const x = rand(0, Math.max(0, vw - w));
        const y = rand(0, Math.max(0, vh - h));
        if (pointOutsideRect(x + w / 2, y + h / 2, rect)) return { x, y };
      }
      return { x: rand(0, Math.max(0, vw - w)), y: rand(0, Math.max(0, vh - h)) };
    }

    // IMPORTANT: open in a NEW TAB
    function openWordPage(versionId) {
      const url = `lang_word.html?id=${encodeURIComponent(versionId)}`;
      window.open(url, "_blank", "noopener,noreferrer");
    }

    function createThought(item) {
      // GET /api/lang_words returns: { word, lang_word_id, version_id, version }
      const { word, version_id } = item;

      const el = document.createElement("div");
      el.className = "thought";
      el.textContent = word;
      el.style.pointerEvents = "auto";
      el.style.cursor = "pointer";

      el.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        openWordPage(version_id);
      });

      const speedPxPerSec = rand(40, 180);
      const jitter = rand(0.6, 2.2);
      const reactRadius = rand(60, 140);
      const reactStrength = rand(0.6, 1.6);

      let pos = { x: rand(0, window.innerWidth * 0.8), y: rand(0, window.innerHeight * 0.8) };
      let target = pickTarget(el);
      let lastT = performance.now();

      el.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0)`;

      function step(now) {
        const dt = Math.min(0.05, (now - lastT) / 1000);
        lastT = now;

        if (prefersReducedMotion) {
          if (Math.random() < 0.01) {
            target = pickTarget(el);
            pos = { ...target };
            el.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0)`;
          }
          requestAnimationFrame(step);
          return;
        }

        let vx = target.x - pos.x;
        let vy = target.y - pos.y;
        const dist = Math.hypot(vx, vy) || 1;

        if (dist < 6) {
          if (Math.random() < 0.08) target = pickTarget(el);
        } else {
          const stepDist = Math.min(dist, speedPxPerSec * dt);
          pos.x += (vx / dist) * stepDist;
          pos.y += (vy / dist) * stepDist;
        }

        pos.x += (Math.random() - 0.5) * jitter;
        pos.y += (Math.random() - 0.5) * jitter;

        if (mouse.x !== null && mouse.y !== null) {
          const dx = pos.x - mouse.x;
          const dy = pos.y - mouse.y;
          const d = Math.hypot(dx, dy) || 1;
          if (d < reactRadius) {
            const force = (1 - d / reactRadius) * reactStrength * 120;
            pos.x += (dx / d) * force * dt;
            pos.y += (dy / d) * force * dt;
          }
        }

        const b = el.getBoundingClientRect();
        const w = b.width || 80;
        const h = b.height || 24;

        const maxX = Math.max(0, window.innerWidth - w);
        const maxY = Math.max(0, window.innerHeight - h);

        if (pos.x < 0) pos.x = 0;
        if (pos.y < 0) pos.y = 0;
        if (pos.x > maxX) pos.x = maxX;
        if (pos.y > maxY) pos.y = maxY;

        el.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0)`;
        requestAnimationFrame(step);
      }

      requestAnimationFrame(step);
      return el;
    }

    async function fetchWords() {
      const res = await fetch(`${API_BASE}/api/lang_words`, { headers: { "Accept": "application/json" } });
      if (!res.ok) throw new Error(`Failed to load words: ${res.status}`);
      const data = await res.json();
      return Array.isArray(data.words) ? data.words : [];
    }

    function mountWords(words) {
      layer.innerHTML = "";
      words.forEach((obj) => layer.appendChild(createThought(obj)));
    }

    function mountList(words) {
      listGrid.innerHTML = "";
      const sorted = [...words].sort((a, b) => String(a.word).localeCompare(String(b.word)));

      sorted.forEach((item) => {
        const a = document.createElement("a");
        a.href = `lang_word.html?id=${encodeURIComponent(item.version_id)}`;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = item.word;
        a.addEventListener("click", (e) => {
          // ensure consistent "new tab" behavior even if browser ignores target
          e.preventDefault();
          openWordPage(item.version_id);
        });
        listGrid.appendChild(a);
      });

      listMeta.textContent = `${sorted.length} words`;
    }

    async function refreshWords() {
      try {
        const words = await fetchWords();
        cachedWords = words;

        if (listMode) {
          mountList(words);
        } else {
          mountWords(words);
        }
      } catch (err) {
        console.error(err);
        cachedWords = [];
        if (listMode) {
          mountList([]);
        } else {
          mountWords([]);
        }
      }
    }

    function setListMode(on) {
      listMode = !!on;
      document.body.classList.toggle("list-mode", listMode);
      listPanel.style.display = listMode ? "block" : "none";
      listToggleBtn.textContent = listMode ? "✕" : "☰";

      // mount appropriate view from cache immediately
      if (listMode) {
        mountList(cachedWords);
      } else {
        mountWords(cachedWords);
      }
    }

    function getAdminKeyFromStorage() {
      return localStorage.getItem(ADMIN_KEY_STORAGE) || "";
    }

    function requestAdminKey() {
      const existing = getAdminKeyFromStorage();
      const key = window.prompt("Admin key required to add words:", existing || "");
      if (key && key.trim()) {
        localStorage.setItem(ADMIN_KEY_STORAGE, key.trim());
        return key.trim();
      }
      return "";
    }

    async function createWord(word, adminKey) {
      // POST /api/lang_words returns: { ok, lang_word_id, version_id, word }
      const res = await fetch(`${API_BASE}/api/lang_words`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-Admin-Key": adminKey
        },
        body: JSON.stringify({ word })
      });

      if (res.status === 401) throw new Error("Unauthorized: invalid admin key.");
      if (res.status === 409) throw new Error("That word already exists.");
      if (!res.ok) {
        const data = await res.json().catch(() => ({}));
        throw new Error(data.error || `Create failed: ${res.status}`);
      }
      return res.json();
    }

    addBtn.addEventListener("click", async () => {
      const word = (window.prompt("New lang word:") || "").trim();
      if (!word) return;

      let adminKey = getAdminKeyFromStorage();
      if (!adminKey) adminKey = requestAdminKey();
      if (!adminKey) return;

      try {
        const out = await createWord(word, adminKey);
        await refreshWords();

        // Optional: open newly created word in new tab
        if (out && out.version_id) {
          openWordPage(out.version_id);
        }
      } catch (err) {
        alert(err.message || String(err));
        if ((err.message || "").toLowerCase().includes("admin key")) {
          localStorage.removeItem(ADMIN_KEY_STORAGE);
        }
      }
    });

    listToggleBtn.addEventListener("click", async () => {
      // Toggle list mode; refresh if we don't have words yet
      setListMode(!listMode);
      if (!cachedWords.length) await refreshWords();
    });

    // Initial mount
    refreshWords();

    window.addEventListener("resize", () => {
      // Keep words consistent on resize (only remount moving layer)
      if (!listMode) refreshWords();
    });
  </script>
</body>
</html>
