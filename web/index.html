<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>fantasiagenesis</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; line-height: 1.5; }
    main { max-width: 42rem; margin: 10vh auto; text-align: center; }
    h1 { font-size: 1.25rem; margin: 0 0 1rem; }
    p { margin: 0 0 1.25rem; }
    nav a { display: inline-block; margin: .25rem .5rem; text-decoration: none; padding: .5rem .75rem; border-radius: .5rem; border: 1px solid currentColor; }
    nav a:focus { outline: 2px solid currentColor; outline-offset: 2px; }
    .media-row { display: flex; gap: 1rem; align-items: stretch; justify-content: center; }
    .media-row img,
    .media-row video { width: 100%; max-width: 14rem; height: auto; object-fit: cover; border-radius: .25rem; }
    @media (max-width: 720px) {
      .media-row { flex-direction: column; }
      .media-row img,
      .media-row video { max-width: 100%; }
    }

    #word-layer {
    position: fixed;
    inset: 0;
    pointer-events: none; /* words don't block clicks */
    z-index: 0; /* set to 9999 if you want them ABOVE everything */
    overflow: hidden;
  }

  .thought {
    position: absolute;
    left: 0;
    top: 0;
    transform: translate3d(0,0,0);
    padding: .25rem .5rem;
    border-radius: .75rem;
    border: 1px solid color-mix(in oklab, currentColor 70%, transparent);
    background: color-mix(in oklab, Canvas 85%, transparent);
    backdrop-filter: blur(4px);
    font-size: .95rem;
    white-space: nowrap;
    opacity: .85;
    will-change: transform;
    user-select: none;
  }

  /* Keep your main above if words are behind */
  main { position: relative; z-index: 1; }

  @media (prefers-reduced-motion: reduce) {
    .thought { transition: none !important; }
  }
  </style>
</head>
<body>
  <div id="word-layer" aria-hidden="true"></div>

  <main>
    <p><a href="https://github.com/b0risfosso/lang" target="_blank" rel="noopener noreferrer">lang</a></p>
    <div class="media-row">
      <img
        src="Michelangelo_-_Creation_of_Adam_(cropped)-2.jpg"
        alt="Michelangelo, The Creation of Adam (cropped)"
        loading="lazy"
      />
      <video controls autoplay loop muted playsinline preload="metadata">
        <source src="YTDown.com_YouTube_I-think-I-can-I-think-I-can-the-Little-E_Media_Yx9xO98kcBU_001_360p.mp4" type="video/mp4" />
        Sorry, your browser does not support embedded videos.
      </video>
      <video controls autoplay loop muted playsinline preload="metadata">
        <source src="YTDown.com_YouTube_Interstellar-Gargantua-Detach-Scene-1080_Media__GdEsdEfZvc_001_720p.mp4" type="video/mp4" />
        Sorry, your browser does not support embedded videos.
      </video>
    </div>
  </main>

  <script>
    // ==== CONFIG ====
    const WORDS = [
      "solar panels", "manufacturing"
    ];
  
    // If true, tries to avoid your centered <main> area by keeping words outside its rectangle.
    const AVOID_MAIN = true;
  
    // ==== IMPLEMENTATION ====
    const layer = document.getElementById("word-layer");
    const mainEl = document.querySelector("main");
  
    const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  
    const rand = (min, max) => Math.random() * (max - min) + min;
  
    // Track cursor for "react" behavior
    const mouse = { x: null, y: null };
    window.addEventListener("pointermove", (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    }, { passive: true });
  
    function getAvoidRect() {
      if (!AVOID_MAIN || !mainEl) return null;
      const r = mainEl.getBoundingClientRect();
      // Inflate it a bit so words don't hug the content
      const pad = 24;
      return {
        left: r.left - pad,
        top: r.top - pad,
        right: r.right + pad,
        bottom: r.bottom + pad
      };
    }
  
    function pointOutsideRect(x, y, rect) {
      if (!rect) return true;
      return (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom);
    }
  
    function pickTarget(el) {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rect = getAvoidRect();
  
      // measure element for bounds
      const b = el.getBoundingClientRect();
      const w = b.width || 80;
      const h = b.height || 24;
  
      // Try a few times to find a target outside main
      for (let i = 0; i < 25; i++) {
        const x = rand(0, Math.max(0, vw - w));
        const y = rand(0, Math.max(0, vh - h));
        if (pointOutsideRect(x + w / 2, y + h / 2, rect)) return { x, y };
      }
      // fallback anywhere
      return {
        x: rand(0, Math.max(0, vw - w)),
        y: rand(0, Math.max(0, vh - h))
      };
    }
  
    function createThought(word) {
      const el = document.createElement("div");
      el.className = "thought";
      el.textContent = word;
  
      // per-word personality
      const speedPxPerSec = rand(40, 180);      // wander speed
      const jitter = rand(0.6, 2.2);            // tiny jitter strength
      const reactRadius = rand(60, 140);        // cursor influence radius
      const reactStrength = rand(0.6, 1.6);     // cursor repel strength
  
      // state
      let pos = { x: rand(0, window.innerWidth * 0.8), y: rand(0, window.innerHeight * 0.8) };
      let target = pickTarget(el);
      let lastT = performance.now();
  
      // initial placement
      el.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0)`;
  
      function step(now) {
        const dt = Math.min(0.05, (now - lastT) / 1000); // clamp
        lastT = now;
  
        if (prefersReducedMotion) {
          // Just sit near a random spot and occasionally teleport gently
          if (Math.random() < 0.01) {
            target = pickTarget(el);
            pos = { ...target };
            el.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0)`;
          }
          requestAnimationFrame(step);
          return;
        }
  
        // vector toward target
        let vx = target.x - pos.x;
        let vy = target.y - pos.y;
        const dist = Math.hypot(vx, vy) || 1;
  
        // If close, pick a new target after a short pause
        if (dist < 6) {
          if (Math.random() < 0.08) target = pickTarget(el);
        } else {
          // move toward target with per-word speed
          const stepDist = Math.min(dist, speedPxPerSec * dt);
          pos.x += (vx / dist) * stepDist;
          pos.y += (vy / dist) * stepDist;
        }
  
        // subtle jitter (thinking)
        pos.x += (Math.random() - 0.5) * jitter;
        pos.y += (Math.random() - 0.5) * jitter;
  
        // react to cursor (repel slightly)
        if (mouse.x !== null && mouse.y !== null) {
          const dx = pos.x - mouse.x;
          const dy = pos.y - mouse.y;
          const d = Math.hypot(dx, dy) || 1;
          if (d < reactRadius) {
            const force = (1 - d / reactRadius) * reactStrength * 120; // px/sec-ish
            pos.x += (dx / d) * force * dt;
            pos.y += (dy / d) * force * dt;
          }
        }
  
        // keep within bounds
        const b = el.getBoundingClientRect();
        const w = b.width || 80;
        const h = b.height || 24;
  
        const maxX = Math.max(0, window.innerWidth - w);
        const maxY = Math.max(0, window.innerHeight - h);
  
        if (pos.x < 0) pos.x = 0;
        if (pos.y < 0) pos.y = 0;
        if (pos.x > maxX) pos.x = maxX;
        if (pos.y > maxY) pos.y = maxY;
  
        el.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0)`;
        requestAnimationFrame(step);
      }
  
      requestAnimationFrame(step);
      return el;
    }
  
    function mountWords() {
      layer.innerHTML = "";
      WORDS.forEach((w) => layer.appendChild(createThought(w)));
    }
  
    mountWords();
    window.addEventListener("resize", () => {
      // Re-mount so measurements are correct after layout changes
      mountWords();
    });
  </script>
  
</body>
</html>
