<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>write</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; line-height: 1.35; }
    header { padding: 14px 16px; border-bottom: 1px solid color-mix(in oklab, currentColor 22%, transparent); display:flex; gap:12px; align-items:baseline; justify-content:space-between; }
    header h1 { font-size: 18px; margin: 0; }
    header nav a { margin-right: 10px; }
    a { text-decoration: none; border-bottom: 1px solid currentColor; }
    .wrap { display: grid; grid-template-columns: 1fr 1fr; min-height: calc(100vh - 60px); }
    .panel { padding: 16px; overflow:auto; }
    .panel + .panel { border-left: 1px solid color-mix(in oklab, currentColor 22%, transparent); }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .muted { opacity: .75; }
    .pill { display:inline-block; border: 1px solid color-mix(in oklab, currentColor 60%, transparent); border-radius: 999px; padding: 2px 10px; font-size: 12px; }
    button { font: inherit; padding: 8px 10px; border-radius: 10px; border: 1px solid color-mix(in oklab, currentColor 30%, transparent); background: transparent; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    input, textarea, select { font: inherit; padding: 8px 10px; border-radius: 10px; border: 1px solid color-mix(in oklab, currentColor 30%, transparent); background: transparent; }
    textarea { width: 100%; min-height: 80px; resize: vertical; }
    details { border: 1px solid color-mix(in oklab, currentColor 18%, transparent); border-radius: 14px; padding: 10px 12px; margin: 10px 0; }
    details details { margin: 8px 0 0; }
    summary { cursor: pointer; user-select: none; }
    ul { margin: 8px 0; padding-left: 18px; }
    li { margin: 4px 0; }
    .card { border: 1px solid color-mix(in oklab, currentColor 18%, transparent); border-radius: 14px; padding: 12px; margin: 10px 0; }
    .danger { border-color: color-mix(in oklab, red 55%, currentColor 18%); }
    .tabs { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .tab { padding: 6px 10px; border-radius: 999px; border: 1px solid color-mix(in oklab, currentColor 30%, transparent); cursor:pointer; }
    .tab[aria-selected="true"] { background: color-mix(in oklab, currentColor 12%, transparent); }
    pre { white-space: pre-wrap; word-break: break-word; margin: 8px 0 0; font-size: 12px; opacity: .9; }
    .tiny { font-size: 12px; }
    .spacer { height: 8px; }
    .indent { margin-left: 14px; border-left: 2px solid color-mix(in oklab, currentColor 12%, transparent); padding-left: 12px; }
    .loading { opacity: .8; font-style: italic; }
  </style>
</head>
<body>
<header>
  <div class="row">
    <h1>write</h1>
    <span class="pill" id="modePill">word mode</span>
  </div>
  <nav class="tiny">
    <a href="./">home</a>
    <a href="lang.html">sentences</a>
  </nav>
</header>

<div class="wrap">
  <!-- READ -->
  <section class="panel">
    <div class="row" style="justify-content:space-between;">
      <div class="row">
        <strong>read</strong>
        <span class="muted tiny" id="readMeta">…</span>
      </div>
      <div class="row">
        <input id="searchInput" placeholder="search words…" style="min-width: 150px;" />
        <button id="refreshBtn" type="button">refresh</button>
      </div>
    </div>

    <div class="spacer"></div>

    <div class="tabs" role="tablist" aria-label="mode">
      <div class="tab" role="tab" tabindex="0" id="tabWord" aria-selected="true">word</div>
      <div class="tab" role="tab" tabindex="0" id="tabSentence" aria-selected="false">sentence</div>
      <span class="muted tiny" id="adminStatus">admin: unknown</span>
    </div>

    <div class="spacer"></div>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div>
          <strong>selected parent lang word</strong>
          <div class="muted tiny">the parent word acts like the old “lang” selector</div>
        </div>
        <span class="pill" id="selectedParentPill">none</span>
      </div>
      <div class="spacer"></div>

      <div class="row">
        <input id="newParentInput" placeholder="create parent lang word…" style="flex:1; min-width: 220px;" />
        <button id="createParentBtn" type="button">create</button>
      </div>
      <div class="muted tiny" id="createParentHint">requires admin key in localStorage "lang_admin_key"</div>
    </div>

    <div id="readTree"></div>
  </section>

  <!-- WRITE -->
  <section class="panel">
    <div class="row" style="justify-content:space-between;">
      <div class="row">
        <strong>write</strong>
        <span class="muted tiny" id="writeMeta">…</span>
      </div>
      <div class="row">
        <button id="clearKeyBtn" type="button">clear admin key</button>
      </div>
    </div>

    <div class="spacer"></div>

    <!-- WORD MODE -->
    <div id="wordMode">
      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <div>
            <strong>generate child lang words (themes)</strong>
            <div class="muted tiny">creates themes under the selected parent word; each theme gets orbiting phrases as child words</div>
          </div>
          <span class="pill" id="taskStatusPill">idle</span>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <input id="modifierInput" placeholder="optional modifier…" style="flex:1; min-width: 240px;" />
          <button id="runBtn" type="button" disabled>generate themes</button>
        </div>
        <div class="muted tiny" id="runHint">needs a selected parent word + admin key</div>
      </div>

      <div class="card" id="manualEditCard">
        <div class="row" style="justify-content:space-between;">
          <div>
            <strong>manual edit selected parent</strong>
            <div class="muted tiny">create versions, add child lang words, and add child words for a specific version</div>
          </div>
          <span class="pill" id="manualMetaPill">—</span>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <select id="manualVersionSelect" style="flex:1; min-width:240px;"></select>
          <button id="createVersionBtn" type="button" disabled>new version</button>
        </div>
        <div class="muted tiny">Pick a version to add items to. Creating a version requires admin key + selected parent.</div>

        <div class="spacer"></div>

        <details>
          <summary><strong>add child lang word</strong> <span class="muted tiny">(links an existing lang_word_id)</span></summary>
          <div style="margin-top:10px;" class="row">
            <input id="addChildLangWordIdInput" placeholder="existing child lang_word_id…" style="flex:1; min-width:220px;" />
            <button id="addChildLangWordBtn" type="button" disabled>add</button>
          </div>
          <div class="muted tiny">This creates a link in <code class="inline">lang_word_children</code> for the selected version.</div>

          <div class="spacer"></div>

          <div class="muted tiny">or create a new lang word + link it:</div>
          <div style="margin-top:6px;" class="row">
            <input id="createAndLinkLangWordInput" placeholder="new child lang word text…" style="flex:1; min-width:220px;" />
            <button id="createAndLinkLangWordBtn" type="button" disabled>create + link</button>
          </div>
        </details>

        <details style="margin-top:10px;">
          <summary><strong>add child word</strong> <span class="muted tiny">(orbiting phrase)</span></summary>
          <div style="margin-top:10px;" class="row">
            <input id="addChildWordInput" placeholder="child word…" style="flex:1; min-width:220px;" />
            <input id="addChildWordLinkInput" placeholder="optional link…" style="flex:1; min-width:220px;" />
            <button id="addChildWordBtn" type="button" disabled>add</button>
          </div>
        </details>

        <details style="margin-top:10px;">
          <summary><strong>batch add child lang words</strong> <span class="muted tiny">(multiple lines, each a new word)</span></summary>
          <div style="margin-top:10px;">
            <textarea id="batchChildLangWordsTextarea" placeholder="word1\nword2\nword3" style="width:100%; min-height:80px;"></textarea>
            <div style="margin-top:8px;" class="row">
              <button id="batchAddChildLangWordsBtn" type="button" disabled>batch add</button>
            </div>
            <div class="muted tiny">Each line becomes a child lang word (created if doesn't exist).</div>
          </div>
        </details>

        <details style="margin-top:10px;">
          <summary><strong>batch add child words</strong> <span class="muted tiny">(multiple lines, each a new orbiting phrase)</span></summary>
          <div style="margin-top:10px;">
            <textarea id="batchChildWordsTextarea" placeholder="phrase1\nphrase2\nphrase3" style="width:100%; min-height:80px;"></textarea>
            <div style="margin-top:8px;" class="row">
              <button id="batchAddChildWordsBtn" type="button" disabled>batch add</button>
            </div>
            <div class="muted tiny">Each line becomes a child word (orbiting phrase).</div>
          </div>
        </details>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>temporary writings</strong>
          <button id="refreshWritingsBtn" type="button" disabled>refresh</button>
        </div>
        <div class="muted tiny">review and apply to create child lang words + orbiting child words</div>
        <div id="writings"></div>
      </div>
    </div>

    <!-- SENTENCE MODE -->
    <div id="sentenceMode" style="display:none;">
      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <div>
            <strong>sentence mode</strong>
            <div class="muted tiny">select lang words, filter sentences, and (admin) create sentences</div>
          </div>
          <span class="pill" id="selectedWordsPill">0 selected</span>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <input id="sentenceTextInput" placeholder="new sentence…" style="flex:1; min-width: 240px;" />
          <button id="createSentenceBtn" type="button" disabled>create sentence</button>
        </div>
        <div class="muted tiny">creating requires admin key and at least 1 selected word</div>

        <div class="spacer"></div>

        <div class="row">
          <button id="clearWordsBtn" type="button">clear all selections</button>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>sentences</strong>
          <button id="refreshSentencesBtn" type="button">refresh</button>
        </div>
        <div id="sentences"></div>
      </div>
    </div>

  </section>
</div>

<script>
  // -------------------------
  // Helpers
  // -------------------------
  const $ = (id) => document.getElementById(id);

  function getAdminKey() {
    return localStorage.getItem("lang_admin_key") || "";
  }

  function withAdminHeaders(h = {}) {
    const k = getAdminKey();
    if (k) h["X-Admin-Key"] = k;
    return h;
  }

  async function apiGet(url, { admin = false } = {}) {
    const headers = { "Accept": "application/json" };
    if (admin) Object.assign(headers, withAdminHeaders());
    const res = await fetch(url, { headers });
    if (!res.ok) throw new Error(`GET ${url} failed (${res.status})`);
    return await res.json();
  }

  async function apiDelete(url, { admin = false } = {}) {
    const headers = { "Accept": "application/json" };
    if (admin) Object.assign(headers, withAdminHeaders());
    const res = await fetch(url, { method: "DELETE", headers });
    const text = await res.text();
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch { data = null; }
    if (!res.ok) throw new Error((data && (data.description || data.error)) || `DELETE ${url} failed (${res.status})`);
    return data;
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // -------------------------
  // State
  // -------------------------
  let mode = "word"; // "word" | "sentence"
  let roots = [];
  let selectedParentWordId = null;
  let selectedParentWordText = null;

  const selectedSentenceWordIds = new Set();
  let allSentences = [];

  // Word metadata cache (for recursive expansion)
  // latestVersionByWordId: { [lang_word_id]: latest_version_id }
  const latestVersionByWordId = new Map();
  // nodeCache: { [lang_word_id]: { version_id, version, child_words, child_lang_words } }
  const nodeCache = new Map();

  // -------------------------
  // Admin
  // -------------------------
  async function refreshAdminStatus() {
    const k = getAdminKey();
    if (!k) { $("adminStatus").textContent = "admin: no key"; return false; }
    try {
      await apiGet("/api/admin/ping", { admin: true });
      $("adminStatus").textContent = "admin: ok";
      // enable admin-gated UI if a selection exists
      $("runBtn").disabled = !(getAdminKey() && selectedParentWordId);
      refreshManualEditUI();
      return true;
    } catch {
      $("adminStatus").textContent = "admin: invalid";
      $("runBtn").disabled = true;
      refreshManualEditUI();
      return false;
    }
  }

  // -------------------------
  // Mode switching
  // -------------------------
  function setMode(next) {
    mode = next;
    $("modePill").textContent = next === "word" ? "word mode" : "sentence mode";
    $("tabWord").setAttribute("aria-selected", next === "word" ? "true" : "false");
    $("tabSentence").setAttribute("aria-selected", next === "sentence" ? "true" : "false");
    $("wordMode").style.display = next === "word" ? "" : "none";
    $("sentenceMode").style.display = next === "sentence" ? "" : "none";
    renderReadTree();
    if (next === "sentence") loadSentences();
  }

  $("tabWord").onclick = () => setMode("word");
  $("tabSentence").onclick = () => setMode("sentence");

  // -------------------------
  // Parent selection
  // -------------------------
  let selectedManualVersionId = null;

  function getSelectedParentRoot() {
    if (!selectedParentWordId) return null;
    return (Array.isArray(roots) ? roots : []).find(r => Number(r.lang_word_id) === Number(selectedParentWordId)) || null;
  }

  function refreshManualEditUI({ preferVersionId = null } = {}) {
    const root = getSelectedParentRoot();
    const sel = $("manualVersionSelect");
    if (!sel) return;

    const versions = root && Array.isArray(root.versions) ? root.versions : [];
    sel.innerHTML = "";

    for (const v of versions) {
      const opt = document.createElement("option");
      opt.value = String(v.version_id);
      const cw = Array.isArray(v.child_words) ? v.child_words.length : 0;
      const clw = Array.isArray(v.child_lang_words) ? v.child_lang_words.length : 0;
      opt.textContent = `v${v.version} • version_id ${v.version_id} • ${clw} child lang • ${cw} child words`;
      sel.appendChild(opt);
    }

    // Choose selection
    const desired = preferVersionId ? Number(preferVersionId) : (selectedManualVersionId ? Number(selectedManualVersionId) : null);
    const hasDesired = desired && versions.some(v => Number(v.version_id) === desired);
    if (hasDesired) sel.value = String(desired);
    else if (versions.length) sel.value = String(versions[0].version_id);
    else sel.value = "";

    selectedManualVersionId = sel.value ? Number(sel.value) : null;

    $("manualMetaPill").textContent = root ? `parent: ${root.word} (id ${root.lang_word_id})` : "—";

    const adminOk = !!getAdminKey();
    $("createVersionBtn").disabled = !(adminOk && selectedParentWordId);
    $("addChildLangWordBtn").disabled = !(adminOk && selectedManualVersionId);
    $("createAndLinkLangWordBtn").disabled = !(adminOk && selectedManualVersionId);
    $("addChildWordBtn").disabled = !(adminOk && selectedManualVersionId);
    $("batchAddChildLangWordsBtn").disabled = !(adminOk && selectedManualVersionId);
    $("batchAddChildWordsBtn").disabled = !(adminOk && selectedManualVersionId);
  }

  function setSelectedParent(wordId, wordText) {
    selectedParentWordId = wordId;
    selectedParentWordText = wordText;
    $("selectedParentPill").textContent = wordId ? `${wordText} (id ${wordId})` : "none";
    $("runBtn").disabled = !(getAdminKey() && selectedParentWordId);
    $("refreshWritingsBtn").disabled = !selectedParentWordId;
    refreshManualEditUI();
    loadWritings();
  }

  // -------------------------
  // Recursive node loading
  // -------------------------
  async function refreshWordIndex() {
    // Build latestVersionByWordId
    const data = await apiGet("/api/lang_words");
    const words = Array.isArray(data.words) ? data.words : [];
    latestVersionByWordId.clear();
    for (const w of words) {
      if (w && w.lang_word_id && w.latest_version_id) {
        latestVersionByWordId.set(Number(w.lang_word_id), Number(w.latest_version_id));
      }
    }
  }

  async function loadNodeLatest(langWordId) {
    // If already cached, return.
    if (nodeCache.has(langWordId)) return nodeCache.get(langWordId);

    // Ensure we know latest version id
    if (!latestVersionByWordId.has(langWordId)) {
      await refreshWordIndex();
    }
    const versionId = latestVersionByWordId.get(langWordId);
    if (!versionId) {
      // No versions yet
      const empty = { version_id: null, version: null, child_words: [], child_lang_words: [] };
      nodeCache.set(langWordId, empty);
      return empty;
    }

    const v = await apiGet(`/api/lang_words/${versionId}`);
    const node = {
      version_id: v.version_id,
      version: v.version,
      child_words: Array.isArray(v.child_words) ? v.child_words : [],
      child_lang_words: Array.isArray(v.child_lang_words) ? v.child_lang_words : [],
    };
    nodeCache.set(langWordId, node);
    return node;
  }

  // -------------------------
  // Read tree rendering
  // -------------------------
  function renderReadTree() {
    const host = $("readTree");
    host.innerHTML = "";

    if (!Array.isArray(roots)) roots = [];

    let visibleCount = 0;
    for (const R of roots) {
      if (searchTerm && !R.word.toLowerCase().includes(searchTerm)) continue;
      visibleCount++;
    }

    $("readMeta").textContent = searchTerm ? `${visibleCount} of ${roots.length} parent word(s)` : `${roots.length} parent word(s)`;

    for (const R of roots) {
      if (searchTerm && !R.word.toLowerCase().includes(searchTerm)) continue;

      const d = document.createElement("details");
      d.open = false;

      const s = document.createElement("summary");
      s.innerHTML = `<strong>${escapeHtml(R.word)}</strong> <span class="muted tiny">(id ${R.lang_word_id})</span>`;

      // Select word button on summary line for sentence mode
      if (mode === "sentence") {
        const toggleBtn = document.createElement("button");
        toggleBtn.type = "button";
        const key = R.lang_word_id;
        const isOn = selectedSentenceWordIds.has(key);
        toggleBtn.textContent = isOn ? "✓" : "+";
        toggleBtn.style.padding = "2px 8px";
        toggleBtn.style.borderRadius = "999px";
        toggleBtn.style.marginLeft = "8px";
        toggleBtn.onclick = () => {
          if (selectedSentenceWordIds.has(key)) selectedSentenceWordIds.delete(key);
          else selectedSentenceWordIds.add(key);
          updateSelectedWordsPill();
          renderReadTree();
          renderSentences();
        };
        s.appendChild(toggleBtn);
      }

      d.appendChild(s);

      const btnRow = document.createElement("div");
      btnRow.className = "row";
      btnRow.style.marginTop = "8px";

      // Word mode: allow selecting this parent for the right-side panels
      if (mode === "word") {
        const selBtn = document.createElement("button");
        selBtn.type = "button";
        selBtn.textContent = (selectedParentWordId === R.lang_word_id) ? "selected" : "select";
        selBtn.onclick = () => {
          setSelectedParent(R.lang_word_id, R.word);
          refreshManualEditUI();
        };
        btnRow.appendChild(selBtn);

        // Delete parent word button
        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.textContent = "delete";
        deleteBtn.style.marginLeft = "8px";
        deleteBtn.onclick = async () => {
          if (!confirm(`Delete parent lang word "${R.word}" and all its versions/children?`)) return;
          try {
            await apiDelete(`/api/lang_words/${R.lang_word_id}`, { admin: true });
            nodeCache.clear(); // clear all cache
            await loadWriteTree();
            if (selectedParentWordId === R.lang_word_id) {
              setSelectedParent(null, null);
            }
          } catch (e) {
            alert(String(e.message || e));
          }
        };
        btnRow.appendChild(deleteBtn);
      }

      d.appendChild(btnRow);

      if (mode === "word") {
        // Show latest version only, but allow recursive expansion through child lang words.
        const versions = Array.isArray(R.versions) ? R.versions : [];
        const latest = versions.length ? versions[0] : null;

        const meta = document.createElement("div");
        meta.className = "muted tiny";
        meta.style.marginTop = "8px";
        meta.textContent = latest ? `latest version: v${latest.version} (version_id ${latest.version_id})` : "no versions yet";
        d.appendChild(meta);

        if (latest) {
          // Seed cache for this root's latest node so recursion doesn't refetch
          if (!nodeCache.has(R.lang_word_id)) {
            nodeCache.set(R.lang_word_id, {
              version_id: latest.version_id,
              version: latest.version,
              child_words: Array.isArray(latest.child_words) ? latest.child_words : [],
              child_lang_words: Array.isArray(latest.child_lang_words) ? latest.child_lang_words : [],
            });
            latestVersionByWordId.set(R.lang_word_id, latest.version_id);
          }

          const indent = document.createElement("div");
          indent.className = "indent";
          d.appendChild(indent);

          // Render children recursively
          renderNodeRecursive(R.lang_word_id, R.word, indent, 0);
        }
      } else {
        // Sentence mode: show current children as pickers
        const kids = Array.isArray(R.current_child_lang_words) ? R.current_child_lang_words : [];
        const kidsMeta = document.createElement("div");
        kidsMeta.className = "muted tiny";
        kidsMeta.style.marginTop = "8px";
        kidsMeta.textContent = kids.length ? "child lang words (pickable):" : "no child lang words";
        d.appendChild(kidsMeta);

        if (kids.length) {
          const ul = document.createElement("ul");
          for (const k of kids) {
            const li = document.createElement("li");
            const key = k.lang_word_id;
            const on = selectedSentenceWordIds.has(key);

            const b = document.createElement("button");
            b.type = "button";
            b.textContent = on ? "✓" : "+";
            b.style.padding = "2px 8px";
            b.style.borderRadius = "999px";
            b.onclick = () => {
              if (selectedSentenceWordIds.has(key)) selectedSentenceWordIds.delete(key);
              else selectedSentenceWordIds.add(key);
              updateSelectedWordsPill();
              renderReadTree();
              renderSentences();
            };

            const label = document.createElement("span");
            label.style.marginLeft = "8px";
            label.textContent = `${k.word} (id ${k.lang_word_id})`;

            li.appendChild(b);
            li.appendChild(label);
            ul.appendChild(li);
          }
          d.appendChild(ul);
        }
      }

      host.appendChild(d);
    }
  }

  function renderNodeRecursive(langWordId, wordText, hostEl, depth) {
    // Render one node as a details item that lazy-loads its own latest children.
    const nodeDetails = document.createElement("details");
    nodeDetails.open = false;

    const nodeSummary = document.createElement("summary");
    nodeSummary.innerHTML = `<span>${escapeHtml(wordText)}</span> <span class="muted tiny">(id ${langWordId})</span>`;
    nodeDetails.appendChild(nodeSummary);

    const body = document.createElement("div");
    body.className = "indent";
    body.innerHTML = `<div class="muted tiny loading">expand to load…</div>`;
    nodeDetails.appendChild(body);

    let loaded = false;

    nodeDetails.addEventListener("toggle", async () => {
      if (!nodeDetails.open) return;
      if (loaded) return;
      loaded = true;

      body.innerHTML = `<div class="muted tiny loading">loading…</div>`;
      try {
        const node = await loadNodeLatest(langWordId);
        body.innerHTML = "";

        const vMeta = document.createElement("div");
        vMeta.className = "muted tiny";
        if (node.version) vMeta.textContent = `latest v${node.version} (version_id ${node.version_id})`;
        else vMeta.textContent = "no versions yet";
        body.appendChild(vMeta);

        const kids = Array.isArray(node.child_lang_words) ? node.child_lang_words : [];
        const orb = Array.isArray(node.child_words) ? node.child_words : [];

        if (kids.length) {
          const label = document.createElement("div");
          label.className = "muted tiny";
          label.style.marginTop = "8px";
          label.textContent = "child lang words:";
          body.appendChild(label);

          for (const k of kids) {
            const childContainer = document.createElement("div");
            childContainer.style.display = "flex";
            childContainer.style.alignItems = "center";
            childContainer.style.gap = "8px";
            childContainer.style.marginTop = "4px";
            
            // Delete button
            const deleteBtn = document.createElement("button");
            deleteBtn.type = "button";
            deleteBtn.textContent = "×";
            deleteBtn.style.padding = "2px 6px";
            deleteBtn.style.borderRadius = "999px";
            deleteBtn.style.fontSize = "12px";
            deleteBtn.title = "Delete child lang word link";
            deleteBtn.onclick = async () => {
              if (!confirm(`Delete child lang word "${k.word}" from this version?`)) return;
              try {
                await apiDelete(`/api/lang_word_versions/${node.version_id}/child_lang_words/${k.lang_word_id}`, { admin: true });
                nodeCache.delete(langWordId); // clear cache
                await loadWriteTree();
              } catch (e) {
                alert(String(e.message || e));
              }
            };
            childContainer.appendChild(deleteBtn);
            
            // recurse: render child node as expandable details
            renderNodeRecursive(Number(k.lang_word_id), k.word, childContainer, depth + 1);
            body.appendChild(childContainer);
          }
        }

        if (orb.length) {
          const label = document.createElement("div");
          label.className = "muted tiny";
          label.style.marginTop = "8px";
          label.textContent = "child words (open in stars):";
          body.appendChild(label);

          const ul = document.createElement("ul");
          for (const c of orb) {
            const li = document.createElement("li");
            li.style.display = "flex";
            li.style.alignItems = "center";
            li.style.gap = "8px";
            
            // Delete button
            const deleteBtn = document.createElement("button");
            deleteBtn.type = "button";
            deleteBtn.textContent = "×";
            deleteBtn.style.padding = "2px 6px";
            deleteBtn.style.borderRadius = "999px";
            deleteBtn.style.fontSize = "12px";
            deleteBtn.title = "Delete child word";
            deleteBtn.onclick = async () => {
              if (!confirm(`Delete child word "${c.word}"?`)) return;
              try {
                await apiDelete(`/api/child_words/${c.id}`, { admin: true });
                nodeCache.delete(langWordId); // clear cache
                await loadWriteTree();
              } catch (e) {
                alert(String(e.message || e));
              }
            };
            li.appendChild(deleteBtn);
            
            const link = `stars.html?child_word_id=${encodeURIComponent(c.id)}`;
            const linkEl = document.createElement("a");
            linkEl.href = link;
            linkEl.textContent = escapeHtml(c.word);
            li.appendChild(linkEl);
            
            if (c.link) {
              li.appendChild(document.createTextNode(" "));
              const dot = document.createElement("span");
              dot.className = "muted tiny";
              dot.textContent = "·";
              li.appendChild(dot);
              li.appendChild(document.createTextNode(" "));
              const sourceLink = document.createElement("a");
              sourceLink.className = "muted tiny";
              sourceLink.href = escapeHtml(c.link);
              sourceLink.target = "_blank";
              sourceLink.rel = "noopener noreferrer";
              sourceLink.textContent = "source";
              li.appendChild(sourceLink);
            }
            
            ul.appendChild(li);
          }
          body.appendChild(ul);
        }

        if (!kids.length && !orb.length) {
          const p = document.createElement("div");
          p.className = "muted tiny";
          p.style.marginTop = "8px";
          p.textContent = "no children";
          body.appendChild(p);
        }
      } catch (e) {
        body.innerHTML = `<div class="card danger">${escapeHtml(String(e.message || e))}</div>`;
      }
    });

    hostEl.appendChild(nodeDetails);
  }

  // -------------------------
  // Load write tree
  // -------------------------
  async function loadWriteTree() {
    $("readMeta").textContent = "loading…";
    const data = await apiGet("/api/write");
    roots = Array.isArray(data.roots) ? data.roots : [];

    // refresh index for recursion; also clear cache when tree refreshes
    nodeCache.clear();
    await refreshWordIndex();

    // prime cache for roots latest versions (fast path)
    for (const R of roots) {
      const versions = Array.isArray(R.versions) ? R.versions : [];
      const latest = versions.length ? versions[0] : null;
      if (latest) {
        latestVersionByWordId.set(R.lang_word_id, latest.version_id);
        nodeCache.set(R.lang_word_id, {
          version_id: latest.version_id,
          version: latest.version,
          child_words: Array.isArray(latest.child_words) ? latest.child_words : [],
          child_lang_words: Array.isArray(latest.child_lang_words) ? latest.child_lang_words : [],
        });
      }
    }

    renderReadTree();
    // keep manual edit panel in sync if a parent is already selected
    refreshManualEditUI();
  }

  $("refreshBtn").onclick = () => loadWriteTree();

  // -------------------------
  // Create parent word
  // -------------------------
  $("createParentBtn").onclick = async () => {
    const word = ($("newParentInput").value || "").trim();
    if (!word) return;

    try {
      await apiPost("/api/lang_words/parents", { word }, { admin: true });
      $("newParentInput").value = "";
      await loadWriteTree();
      const hit = roots.find(r => r.word === word);
      if (hit) setSelectedParent(hit.lang_word_id, hit.word);
    } catch (e) {
      alert(String(e.message || e));
    }
  };

  // -------------------------
  // Manual editing (word mode)
  // -------------------------
  $("manualVersionSelect").onchange = () => {
    selectedManualVersionId = $("manualVersionSelect").value ? Number($("manualVersionSelect").value) : null;
    refreshManualEditUI();
  };

  $("createVersionBtn").onclick = async () => {
    if (!selectedParentWordId) return;
    try {
      const res = await apiPost(`/api/lang_words/${selectedParentWordId}/versions`, {}, { admin: true });
      await loadWriteTree();
      // keep selection and focus new version
      const root = roots.find(r => Number(r.lang_word_id) === Number(selectedParentWordId));
      if (root) setSelectedParent(root.lang_word_id, root.word);
      refreshManualEditUI({ preferVersionId: res && res.version_id ? res.version_id : null });
    } catch (e) {
      alert(String(e.message || e));
    }
  };

  $("addChildLangWordBtn").onclick = async () => {
    const versionId = selectedManualVersionId;
    if (!versionId) return;
    const raw = ($("addChildLangWordIdInput").value || "").trim();
    if (!raw) return;
    const childId = Number(raw);
    if (!childId) return alert("invalid child lang_word_id");
    try {
      await apiPost(`/api/lang_word_versions/${versionId}/child_lang_words`, { child_lang_word_id: childId }, { admin: true });
      $("addChildLangWordIdInput").value = "";
      nodeCache.clear(); // clear cache
      await loadWriteTree();
      refreshManualEditUI({ preferVersionId: versionId });
      renderReadTree();
    } catch (e) {
      alert(String(e.message || e));
    }
  };

  $("createAndLinkLangWordBtn").onclick = async () => {
    const versionId = selectedManualVersionId;
    if (!versionId) return;
    const word = ($("createAndLinkLangWordInput").value || "").trim();
    if (!word) return;
    try {
      const w = await apiPost(`/api/lang_words`, { word }, { admin: true });
      await apiPost(`/api/lang_word_versions/${versionId}/child_lang_words`, { child_lang_word_id: w.lang_word_id }, { admin: true });
      $("createAndLinkLangWordInput").value = "";
      nodeCache.clear(); // clear cache
      await loadWriteTree();
      refreshManualEditUI({ preferVersionId: versionId });
      renderReadTree();
    } catch (e) {
      alert(String(e.message || e));
    }
  };

  $("addChildWordBtn").onclick = async () => {
    const versionId = selectedManualVersionId;
    if (!versionId) return;
    const word = ($("addChildWordInput").value || "").trim();
    const link = ($("addChildWordLinkInput").value || "").trim();
    if (!word) return;
    try {
      await apiPost(`/api/lang_word_versions/${versionId}/child_words`, { word, link }, { admin: true });
      $("addChildWordInput").value = "";
      $("addChildWordLinkInput").value = "";
      nodeCache.clear(); // clear cache
      await loadWriteTree();
      refreshManualEditUI({ preferVersionId: versionId });
      renderReadTree();
    } catch (e) {
      alert(String(e.message || e));
    }
  };

  $("batchAddChildLangWordsBtn").onclick = async () => {
    const versionId = selectedManualVersionId;
    if (!versionId) return;
    const text = ($("batchChildLangWordsTextarea").value || "").trim();
    if (!text) return;
    const words = text.split('\n').map(w => w.trim()).filter(w => w);
    if (!words.length) return;
    try {
      await apiPost(`/api/lang_word_versions/${versionId}/child_lang_words/batch`, { words }, { admin: true });
      $("batchChildLangWordsTextarea").value = "";
      nodeCache.clear(); // clear cache
      await loadWriteTree();
      refreshManualEditUI({ preferVersionId: versionId });
      renderReadTree();
    } catch (e) {
      alert(String(e.message || e));
    }
  };

  $("batchAddChildWordsBtn").onclick = async () => {
    const versionId = selectedManualVersionId;
    if (!versionId) return;
    const text = ($("batchChildWordsTextarea").value || "").trim();
    if (!text) return;
    const words = text.split('\n').map(w => w.trim()).filter(w => w);
    if (!words.length) return;
    try {
      await apiPost(`/api/lang_word_versions/${versionId}/child_words/batch`, { words }, { admin: true });
      $("batchChildWordsTextarea").value = "";
      nodeCache.clear(); // clear cache
      await loadWriteTree();
      refreshManualEditUI({ preferVersionId: versionId });
      renderReadTree();
    } catch (e) {
      alert(String(e.message || e));
    }
  };

  // -------------------------
  // Generate themes (enqueue + poll)
  // -------------------------
  async function pollTask(taskId) {
    $("taskStatusPill").textContent = "running";
    while (true) {
      const t = await apiGet(`/api/write/tasks/${taskId}`);
      if (t.status === "done") {
        $("taskStatusPill").textContent = "done";
        return t;
      }
      if (t.status === "error") {
        $("taskStatusPill").textContent = "error";
        throw new Error(t.error || "task failed");
      }
      await new Promise(r => setTimeout(r, 1200));
    }
  }

  $("runBtn").onclick = async () => {
    if (!selectedParentWordId) return;
    const modifier = ($("modifierInput").value || "").trim();
    try {
      $("runBtn").disabled = true;
      $("taskStatusPill").textContent = "queued";
      const res = await apiPost("/api/write/create_lang_words", {
        parent_lang_word_id: selectedParentWordId,
        modifier
      }, { admin: true });

      const taskId = res.task_id;
      await pollTask(taskId);
      await loadWritings();
      await loadWriteTree();
    } catch (e) {
      $("taskStatusPill").textContent = "error";
      alert(String(e.message || e));
    } finally {
      $("runBtn").disabled = !(getAdminKey() && selectedParentWordId);
    }
  };

  // -------------------------
  // Temporary writings
  // -------------------------
  $("refreshWritingsBtn").onclick = () => loadWritings();

  async function loadWritings() {
    const host = $("writings");
    host.innerHTML = "";
    if (!selectedParentWordId) return;

    try {
      const data = await apiGet(`/api/temporary_writings?parent_lang_word_id=${selectedParentWordId}`, { admin: true });
      const arr = Array.isArray(data.writings) ? data.writings : [];
      $("writeMeta").textContent = `${arr.length} writing(s)`;

      for (const w of arr) {
        const card = document.createElement("div");
        card.className = "card";

        const top = document.createElement("div");
        top.className = "row";
        top.style.justifyContent = "space-between";
        top.innerHTML = `<div><strong>writing #${w.id}</strong> <span class="muted tiny">task ${w.task_id ?? "—"} • ${escapeHtml(w.created_at || "")}</span></div>`;
        card.appendChild(top);

        const pre = document.createElement("pre");
        pre.textContent = JSON.stringify(w.text, null, 2);
        card.appendChild(pre);

        const btnRow = document.createElement("div");
        btnRow.className = "row";
        btnRow.style.marginTop = "10px";

        const applyBtn = document.createElement("button");
        applyBtn.type = "button";
        applyBtn.textContent = "create writing (apply)";
        applyBtn.onclick = async () => {
          if (!confirm("Apply this writing? This will create a NEW parent version and link ONLY the new themes.")) return;
          try {
            applyBtn.disabled = true;
            await apiPost(`/api/temporary_writings/${w.id}/apply_create_lang_words`, {}, { admin: true });
            await loadWritings();
            await loadWriteTree();
          } catch (e) {
            alert(String(e.message || e));
          } finally {
            applyBtn.disabled = false;
          }
        };

        btnRow.appendChild(applyBtn);
        card.appendChild(btnRow);
        host.appendChild(card);
      }

      if (!arr.length) {
        const p = document.createElement("div");
        p.className = "muted tiny";
        p.textContent = "no temporary writings yet";
        host.appendChild(p);
      }
    } catch (e) {
      $("writeMeta").textContent = "error";
      const p = document.createElement("div");
      p.className = "card danger";
      p.textContent = String(e.message || e);
      host.appendChild(p);
    }
  }

  // -------------------------
  // Sentence mode
  // -------------------------
  function updateSelectedWordsPill() {
    $("selectedWordsPill").textContent = `${selectedSentenceWordIds.size} selected`;
    $("createSentenceBtn").disabled = !(getAdminKey() && selectedSentenceWordIds.size > 0 && ($("sentenceTextInput").value || "").trim());
  }

  $("sentenceTextInput").addEventListener("input", updateSelectedWordsPill);

  $("refreshSentencesBtn").onclick = () => loadSentences();

  async function loadSentences() {
    const data = await apiGet("/api/lang_sentences");
    allSentences = Array.isArray(data.sentences) ? data.sentences : [];
    renderSentences();
  }

  function renderSentences() {
    const host = $("sentences");
    host.innerHTML = "";

    const selected = Array.from(selectedSentenceWordIds);
    const filtered = allSentences.filter(s => {
      const ids = Array.isArray(s.lang_word_ids) ? s.lang_word_ids : [];
      for (const need of selected) {
        if (!ids.includes(need)) return false;
      }
      return true;
    });

    const meta = document.createElement("div");
    meta.className = "muted tiny";
    meta.textContent = `${filtered.length} sentence(s) match`;
    host.appendChild(meta);

    for (const s of filtered) {
      const card = document.createElement("div");
      card.className = "card";
      const ids = Array.isArray(s.lang_word_ids) ? s.lang_word_ids : [];
      card.innerHTML = `
        <div class="row" style="justify-content:space-between;">
          <div><strong><a href="sentence.html?sentence_id=${s.id}">#${s.id}</a></strong> <span class="muted tiny">updated ${escapeHtml(s.updated_at || "")}</span></div>
          <span class="pill">${ids.length} word(s)</span>
        </div>
        <div style="margin-top:8px;">${escapeHtml(s.sentence || "")}</div>
        <div class="muted tiny" style="margin-top:8px;">lang_word_ids: ${escapeHtml(JSON.stringify(ids))}</div>
      `;
      host.appendChild(card);
    }

    if (!filtered.length) {
      const p = document.createElement("div");
      p.className = "muted tiny";
      p.textContent = "no sentences match the selected words";
      host.appendChild(p);
    }
  }

  $("createSentenceBtn").onclick = async () => {
    const sentence = ($("sentenceTextInput").value || "").trim();
    if (!sentence) return;
    const ids = Array.from(selectedSentenceWordIds);
    if (!ids.length) return;

    try {
      await apiPost("/api/lang_sentences", { lang_word_ids: ids, sentence }, { admin: true });
      $("sentenceTextInput").value = "";
      updateSelectedWordsPill();
      await loadSentences();
    } catch (e) {
      alert(String(e.message || e));
    }
  };

  // -------------------------
  // Admin key clear
  // -------------------------
  $("clearKeyBtn").onclick = () => {
    localStorage.removeItem("lang_admin_key");
    refreshAdminStatus();
    $("runBtn").disabled = true;
    $("createSentenceBtn").disabled = true;
  };

  // -------------------------
  // Sentence mode clear
  // -------------------------
  $("clearWordsBtn").onclick = () => {
    selectedSentenceWordIds.clear();
    updateSelectedWordsPill();
    renderReadTree();
    renderSentences();
  };

  // -------------------------
  // Search
  // -------------------------
  let searchTerm = "";
  $("searchInput").addEventListener("input", (e) => {
    searchTerm = (e.target.value || "").trim().toLowerCase();
    renderReadTree();
  });

  // -------------------------
  // Boot
  // -------------------------
  async function boot() {
    await refreshAdminStatus();
    updateSelectedWordsPill();
    await loadWriteTree();
  }

  boot().catch(err => console.error(err));
</script>
</body>
</html>
