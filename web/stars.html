<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>stars</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; line-height: 1.35; }
    header { padding: 14px 16px; border-bottom: 1px solid color-mix(in oklab, currentColor 22%, transparent); display:flex; gap:12px; align-items:baseline; justify-content:space-between; }
    header h1 { font-size: 18px; margin: 0; }
    header nav a { margin-right: 10px; }
    a { text-decoration: none; border-bottom: 1px solid currentColor; }

    .wrap { display: grid; grid-template-columns: 1fr 1fr; min-height: calc(100vh - 60px); }
    .panel { padding: 16px; overflow:auto; }
    .panel + .panel { border-left: 1px solid color-mix(in oklab, currentColor 22%, transparent); }

    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .muted { opacity: .75; }
    .pill { display:inline-block; border: 1px solid color-mix(in oklab, currentColor 60%, transparent); border-radius: 999px; padding: 2px 10px; font-size: 12px; }
    button { font: inherit; padding: 8px 10px; border-radius: 10px; border: 1px solid color-mix(in oklab, currentColor 30%, transparent); background: transparent; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    input, textarea { font: inherit; padding: 8px 10px; border-radius: 10px; border: 1px solid color-mix(in oklab, currentColor 30%, transparent); background: transparent; }
    textarea { width: 100%; min-height: 90px; resize: vertical; }
    details { border: 1px solid color-mix(in oklab, currentColor 18%, transparent); border-radius: 14px; padding: 10px 12px; margin: 10px 0; }
    summary { cursor: pointer; user-select: none; }
    ul { margin: 8px 0; padding-left: 18px; }
    li { margin: 4px 0; }
    .card { border: 1px solid color-mix(in oklab, currentColor 18%, transparent); border-radius: 14px; padding: 12px; margin: 10px 0; }
    .danger { border-color: color-mix(in oklab, red 55%, currentColor 18%); }
    pre { white-space: pre-wrap; word-break: break-word; margin: 8px 0 0; font-size: 12px; opacity: .95; }
    .tiny { font-size: 12px; }
    code.inline { padding: 2px 6px; border-radius: 8px; border: 1px solid color-mix(in oklab, currentColor 18%, transparent); }

    .indent { margin-left: 14px; border-left: 2px solid color-mix(in oklab, currentColor 12%, transparent); padding-left: 12px; }
    .loading { opacity: .8; font-style: italic; }

    .pickrow { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .pickbtn { padding: 2px 8px; border-radius: 999px; }
    .picklink { border-bottom: 1px solid transparent; }
    .picklink:hover { border-bottom-color: currentColor; }
  </style>
</head>
<body>
<header>
  <div class="row">
    <h1>stars</h1>
    <span class="pill" id="activePill">child_word_id: —</span>
    <span class="pill" id="selectedPill">0 selected</span>
  </div>
  <nav class="tiny">
    <a href="./">home</a>
    <a href="write.html">write</a>
    <a href="lang.html">sentences</a>
  </nav>
</header>

<div class="wrap">
  <section class="panel">
    <div class="row" style="justify-content:space-between;">
      <div class="row">
        <strong>pick child words</strong>
        <span class="muted tiny" id="treeMeta">…</span>
      </div>
      <div class="row">
        <input id="searchInput" placeholder="search parent words…" style="min-width: 180px;" />
        <button id="refreshTreeBtn" type="button">refresh</button>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="clearSelectionBtn" type="button">clear selections</button>
      <span class="muted tiny">Tip: click a child word to focus it on the right; toggle ✓ to multi-select.</span>
    </div>

    <div id="readTree" style="margin-top:10px;"></div>
  </section>

  <section class="panel">
    <div class="row" style="justify-content:space-between;">
      <div class="row">
        <strong>star stuff</strong>
        <span class="muted tiny" id="adminStatus">admin: unknown</span>
      </div>
      <div class="row">
        <button id="refreshBtn" type="button">refresh</button>
        <span class="pill" id="taskPill">idle</span>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div>
          <div class="muted tiny">active child word</div>
          <div class="row" style="margin-top:4px; align-items:baseline;">
            <strong id="childWord">—</strong>
            <a id="childLink" class="muted tiny" target="_blank" rel="noopener noreferrer" style="display:none;">source</a>
          </div>
        </div>
        <div class="muted tiny" id="ctxMeta">—</div>
      </div>

      <div style="margin-top:12px;" class="row">
        <div style="min-width: 180px;">
          <div class="muted tiny">lang name</div>
          <div><strong id="langName">—</strong></div>
        </div>
        <div style="min-width: 180px;">
          <div class="muted tiny">lang word</div>
          <div><strong id="langWord">—</strong> <span class="muted tiny" id="langWordMeta"></span></div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="muted tiny">selected child words (batched runs apply to all)</div>
        <div id="selectedList" class="row" style="margin-top:6px;"></div>
      </div>
    </div>

    <details open>
      <summary><strong>enqueue star stuff</strong> <span class="muted tiny">runs on all selected child words</span></summary>

      <div style="margin-top:10px;">
        <div class="muted tiny">optional modifier</div>
        <textarea id="modifierInput" placeholder="optional modifier…"></textarea>
      </div>

      <div style="margin-top:10px;">
        <div class="muted tiny">select prompts</div>
        <div class="row" style="margin-top:6px;">
          <label class="row" style="gap:8px;"><input type="checkbox" value="create_star_stuff_words" checked /> <span class="tiny">create_star_stuff_words</span></label>
          <label class="row" style="gap:8px;"><input type="checkbox" value="create_star_stuff_images" /> <span class="tiny">create_star_stuff_images</span></label>
          <label class="row" style="gap:8px;"><input type="checkbox" value="create_star_stuff_data" /> <span class="tiny">create_star_stuff_data</span></label>
          <label class="row" style="gap:8px;"><input type="checkbox" value="create_star_stuff_synthetic_data" /> <span class="tiny">create_star_stuff_synthetic_data</span></label>
          <label class="row" style="gap:8px;"><input type="checkbox" value="create_star_stuff_code" /> <span class="tiny">create_star_stuff_code</span></label>
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <button id="runBtn" type="button" disabled>enqueue selected</button>
        <span class="muted tiny">Requires admin key in localStorage <code class="inline">lang_admin_key</code>.</span>
      </div>
    </details>

    <details>
      <summary><strong>manual star stuff</strong> <span class="muted tiny">create for active child word</span></summary>

      <div style="margin-top:10px;">
        <div class="muted tiny">prompt type</div>
        <input id="manualPromptTypeInput" placeholder="e.g. manual_notes" />
      </div>

      <div style="margin-top:10px;">
        <div class="muted tiny">model (optional)</div>
        <input id="manualModelInput" placeholder="e.g. gpt-5-mini-2025-08-07" />
      </div>

      <div style="margin-top:10px;">
        <div class="muted tiny">modifier (optional)</div>
        <input id="manualModifierInput" placeholder="optional modifier…" />
      </div>

      <div style="margin-top:10px;">
        <div class="muted tiny">text</div>
        <textarea id="manualTextInput" placeholder="paste or type star stuff…"></textarea>
      </div>

      <div class="row" style="margin-top:12px;">
        <button id="manualCreateBtn" type="button" disabled>create star stuff</button>
        <span class="muted tiny">Uses the active child word on the right.</span>
      </div>
    </details>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="row">
          <strong>existing star stuff (active child)</strong>
          <button id="copyAllStuffBtn" class="btn-sm" type="button" disabled>copy all</button>
        </div>
        <span class="muted tiny" id="meta">…</span>
      </div>
      <div id="stuff" style="margin-top:10px;"></div>
    </div>
  </section>
</div>

<script>
  const $ = (id) => document.getElementById(id);

  function getAdminKey() { return localStorage.getItem("lang_admin_key") || ""; }
  function withAdminHeaders(h = {}) { const k = getAdminKey(); if (k) h["X-Admin-Key"] = k; return h; }

  async function apiGet(url, { admin = false } = {}) {
    const headers = { "Accept": "application/json" };
    if (admin) Object.assign(headers, withAdminHeaders());
    const res = await fetch(url, { headers });
    if (!res.ok) throw new Error(`GET ${url} failed (${res.status})`);
    return await res.json();
  }

  async function apiPost(url, body, { admin = false } = {}) {
    const headers = { "Content-Type": "application/json", "Accept": "application/json" };
    if (admin) Object.assign(headers, withAdminHeaders());
    const res = await fetch(url, { method: "POST", headers, body: JSON.stringify(body || {}) });
    const txt = await res.text();
    let data = null;
    try { data = txt ? JSON.parse(txt) : null; } catch { data = null; }
    if (!res.ok) throw new Error((data && (data.description || data.error)) || `POST ${url} failed (${res.status})`);
    return data;
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  async function copyTextToClipboard(text) {
    const value = String(text || "");
    if (!value) return;
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(value);
      return;
    }
    const ta = document.createElement("textarea");
    ta.value = value;
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
  }

  function selectedPrompts() {
    return Array.from(document.querySelectorAll('input[type="checkbox"]'))
      .filter(x => x.checked)
      .map(x => x.value);
  }

  function getChildWordIdFromUrl() {
    const u = new URL(location.href);
    const v = u.searchParams.get("child_word_id");
    return v ? Number(v) : 0;
  }

  function setUrlChildWordId(childId, { replace = false } = {}) {
    const u = new URL(location.href);
    if (childId) u.searchParams.set("child_word_id", String(childId));
    else u.searchParams.delete("child_word_id");
    if (replace) history.replaceState({}, "", u.toString());
    else history.pushState({}, "", u.toString());
  }

  async function refreshAdminStatus() {
    const k = getAdminKey();
    if (!k) {
      $("adminStatus").textContent = "admin: no key";
      adminOk = false;
      updateManualStarEnabled();
      return false;
    }
    try {
      await apiGet("/api/admin/ping", { admin: true });
      $("adminStatus").textContent = "admin: ok";
      adminOk = true;
      updateManualStarEnabled();
      return true;
    } catch {
      $("adminStatus").textContent = "admin: invalid";
      adminOk = false;
      updateManualStarEnabled();
      return false;
    }
  }

  async function pollTask(taskId) {
    while (true) {
      const t = await apiGet(`/api/tasks/${taskId}`);
      if (t.status === "done") return t;
      if (t.status === "error") throw new Error(t.error || "task failed");
      await new Promise(r => setTimeout(r, 1200));
    }
  }

  // ---- Tree state (adapted from write.html recursion)
  let roots = [];
  let searchTerm = "";
  const latestVersionByWordId = new Map();
  const nodeCache = new Map();
  const selectedReadVersionByWordId = new Map();

  const selectedChildWordIds = new Set();
  const selectedChildWordLabels = new Map();
  let activeChildWordId = null;
  const openDetailsIds = new Set();
  let adminOk = false;

  function updateManualStarEnabled() {
    const ok = !!getAdminKey() && adminOk && !!activeChildWordId;
    $("manualCreateBtn").disabled = !ok;
  }

  function updateSelectionUI() {
    $("selectedPill").textContent = `${selectedChildWordIds.size} selected`;
    $("runBtn").disabled = !(getAdminKey() && selectedChildWordIds.size > 0);
    renderSelectedList();
    updateManualStarEnabled();
  }

  function renderSelectedList() {
    const host = $("selectedList");
    host.innerHTML = "";
    if (!selectedChildWordIds.size) {
      host.innerHTML = `<span class="muted tiny">none</span>`;
      return;
    }
    for (const id of Array.from(selectedChildWordIds)) {
      const label = selectedChildWordLabels.get(id) || `child_word_id ${id}`;
      const pill = document.createElement("button");
      pill.type = "button";
      pill.className = "pill";
      const star = id === activeChildWordId ? "★ " : "";
      const labelSpan = document.createElement("span");
      labelSpan.textContent = star + label;
      pill.appendChild(labelSpan);
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "tiny";
      removeBtn.style.border = "none";
      removeBtn.style.background = "transparent";
      removeBtn.style.cursor = "pointer";
      removeBtn.textContent = " ✕";
      removeBtn.onclick = (ev) => {
        ev.stopPropagation();
        selectedChildWordIds.delete(id);
        if (activeChildWordId === id) {
          activeChildWordId = selectedChildWordIds.size ? Array.from(selectedChildWordIds)[0] : null;
          if (activeChildWordId) setUrlChildWordId(activeChildWordId);
          else setUrlChildWordId(null);
        }
        updateSelectionUI();
        loadActiveChild();
        renderReadTree();
      };
      pill.appendChild(removeBtn);
      pill.onclick = () => setActiveChild(id, { ensureSelected: true, pushUrl: true });
      pill.title = "Click label to focus. Click ✕ to remove from selection.";
      host.appendChild(pill);
    }
  }

  async function refreshWordIndex() {
    const data = await apiGet("/api/lang_words");
    const words = Array.isArray(data.words) ? data.words : [];
    latestVersionByWordId.clear();
    for (const w of words) {
      if (w && w.lang_word_id && w.latest_version_id) {
        latestVersionByWordId.set(Number(w.lang_word_id), Number(w.latest_version_id));
      }
    }
  }

  async function loadNodeLatest(langWordId) {
    if (nodeCache.has(langWordId)) return nodeCache.get(langWordId);

    if (!latestVersionByWordId.has(langWordId)) {
      await refreshWordIndex();
    }
    const versionId = latestVersionByWordId.get(langWordId);
    if (!versionId) {
      const empty = { version_id: null, version: null, child_words: [], child_lang_words: [] };
      nodeCache.set(langWordId, empty);
      return empty;
    }

    const v = await apiGet(`/api/lang_words/${versionId}`);
    const node = {
      version_id: v.version_id,
      version: v.version,
      child_words: Array.isArray(v.child_words) ? v.child_words : [],
      child_lang_words: Array.isArray(v.child_lang_words) ? v.child_lang_words : [],
    };
    nodeCache.set(langWordId, node);
    return node;
  }

  function toggleChildSelection(childId, label) {
    if (selectedChildWordIds.has(childId)) selectedChildWordIds.delete(childId);
    else selectedChildWordIds.add(childId);

    if (label) selectedChildWordLabels.set(childId, label);
    if (!activeChildWordId && selectedChildWordIds.has(childId)) {
      activeChildWordId = childId;
      setUrlChildWordId(childId, { replace: true });
    }
    updateSelectionUI();
  }

  function setActiveChild(childId, { ensureSelected = false, pushUrl = false } = {}) {
    if (!childId) return;
    activeChildWordId = childId;
    if (ensureSelected) selectedChildWordIds.add(childId);
    updateSelectionUI();
    if (pushUrl) setUrlChildWordId(childId);
    $("activePill").textContent = `child_word_id: ${childId}`;
    loadActiveChild().catch(e => {
      console.error(e);
      $("stuff").innerHTML = `<div class="card danger">${escapeHtml(String(e.message || e))}</div>`;
    });
    renderReadTree();
  }

  function renderReadTree() {
    const host = $("readTree");

    // Preserve open states
    openDetailsIds.clear();
    for (const d of host.querySelectorAll('details[open]')) {
      const id = d.getAttribute('data-lang-word-id');
      if (id) openDetailsIds.add(Number(id));
    }

    host.innerHTML = "";

    const q = (searchTerm || "").toLowerCase().trim();
    const searchMode = q.length > 0;
    if (searchMode) openDetailsIds.clear();

    const filteredRoots = roots.filter(r => {
      if (!searchMode) return !q || String(r.word || "").toLowerCase().includes(q);
      const nameMatch = String(r.word || "").toLowerCase().includes(q);
      const latest = Array.isArray(r.versions) ? r.versions[0] : null;
      const kids = latest && Array.isArray(latest.child_lang_words) ? latest.child_lang_words : [];
      const childMatch = kids.some(k => String(k.word || "").toLowerCase().includes(q));
      return nameMatch || childMatch;
    });

    $("treeMeta").textContent = searchMode
      ? `${filteredRoots.length} of ${roots.length} parent(s)`
      : `${roots.length} parent(s)`;

    for (const R of filteredRoots) {
      const d = document.createElement("details");
      d.setAttribute('data-lang-word-id', R.lang_word_id);
      if (searchMode) openDetailsIds.add(R.lang_word_id);
      d.open = openDetailsIds.has(R.lang_word_id);

      const s = document.createElement("summary");
      s.innerHTML = `<strong>${escapeHtml(R.word)}</strong> <span class="muted tiny">(id ${R.lang_word_id})</span>`;
      d.appendChild(s);

      const versions = Array.isArray(R.versions) ? R.versions : [];
      const latest = versions.length ? versions[0] : null;
      const pid = Number(R.lang_word_id);

      let selectedVersionId = selectedReadVersionByWordId.get(pid);
      const selectedExists = versions.some(v => Number(v.version_id) === Number(selectedVersionId));
      if (!selectedExists) {
        selectedVersionId = latest ? latest.version_id : null;
        if (selectedVersionId) selectedReadVersionByWordId.set(pid, selectedVersionId);
        else selectedReadVersionByWordId.delete(pid);
      }

      const selectedVersion = versions.find(v => Number(v.version_id) === Number(selectedVersionId)) || null;

      const meta = document.createElement("div");
      meta.className = "row";
      meta.style.marginTop = "8px";

      const metaLabel = document.createElement("span");
      metaLabel.className = "muted tiny";
      metaLabel.textContent = "version:";
      meta.appendChild(metaLabel);

      if (versions.length) {
        const sel = document.createElement("select");
        sel.style.marginLeft = "8px";
        for (const v of versions) {
          const opt = document.createElement("option");
          opt.value = String(v.version_id);
          opt.textContent = `v${v.version} (version_id ${v.version_id})`;
          sel.appendChild(opt);
        }
        if (selectedVersionId) sel.value = String(selectedVersionId);
        sel.onchange = () => {
          const nextId = Number(sel.value);
          selectedReadVersionByWordId.set(pid, nextId);
          const v = versions.find(x => Number(x.version_id) === nextId);
          if (v) {
            nodeCache.set(pid, {
              version_id: v.version_id,
              version: v.version,
              child_words: Array.isArray(v.child_words) ? v.child_words : [],
              child_lang_words: Array.isArray(v.child_lang_words) ? v.child_lang_words : [],
            });
          } else {
            nodeCache.delete(pid);
          }
          renderReadTree();
        };
        meta.appendChild(sel);
      } else {
        const none = document.createElement("span");
        none.className = "muted tiny";
        none.style.marginLeft = "8px";
        none.textContent = "no versions yet";
        meta.appendChild(none);
      }

      d.appendChild(meta);

      if (selectedVersion) {
        nodeCache.set(pid, {
          version_id: selectedVersion.version_id,
          version: selectedVersion.version,
          child_words: Array.isArray(selectedVersion.child_words) ? selectedVersion.child_words : [],
          child_lang_words: Array.isArray(selectedVersion.child_lang_words) ? selectedVersion.child_lang_words : [],
        });

        const indent = document.createElement("div");
        indent.className = "indent";
        d.appendChild(indent);
        renderNodeRecursive(R.lang_word_id, R.word, indent);
      }

      host.appendChild(d);
    }
  }

  function renderNodeRecursive(langWordId, wordText, hostEl) {
    const nodeDetails = document.createElement("details");
    nodeDetails.setAttribute('data-lang-word-id', langWordId);
    nodeDetails.open = openDetailsIds.has(langWordId);

    const nodeSummary = document.createElement("summary");
    nodeSummary.innerHTML = `<span>${escapeHtml(wordText)}</span> <span class="muted tiny">(id ${langWordId})</span>`;
    nodeDetails.appendChild(nodeSummary);

    const body = document.createElement("div");
    body.className = "indent";
    body.innerHTML = `<div class="muted tiny loading">expand to load…</div>`;
    nodeDetails.appendChild(body);

    let loaded = false;

    nodeDetails.addEventListener("toggle", async () => {
      if (nodeDetails.open) {
        openDetailsIds.add(langWordId);
      } else {
        openDetailsIds.delete(langWordId);
      }
      if (!nodeDetails.open) return;
      if (loaded) return;
      loaded = true;

      body.innerHTML = `<div class="muted tiny loading">loading…</div>`;
      try {
        const node = await loadNodeLatest(langWordId);
        body.innerHTML = "";

        const vMeta = document.createElement("div");
        vMeta.className = "muted tiny";
        if (node.version) vMeta.textContent = `version v${node.version} (version_id ${node.version_id})`;
        else vMeta.textContent = "no versions yet";
        body.appendChild(vMeta);

        const kids = Array.isArray(node.child_lang_words) ? node.child_lang_words : [];
        const orb = Array.isArray(node.child_words) ? node.child_words : [];

        if (kids.length) {
          const label = document.createElement("div");
          label.className = "muted tiny";
          label.style.marginTop = "8px";
          label.textContent = "child lang words:";
          body.appendChild(label);

          for (const k of kids) {
            renderNodeRecursive(Number(k.lang_word_id), k.word, body);
          }
        }

        if (orb.length) {
          const label = document.createElement("div");
          label.className = "muted tiny";
          label.style.marginTop = "8px";
          label.textContent = "child words (select for stars):";
          body.appendChild(label);

          const selectAllBtn = document.createElement("button");
          selectAllBtn.type = "button";
          selectAllBtn.className = "pickbtn";
          selectAllBtn.textContent = "select all";
          selectAllBtn.onclick = () => {
            for (const c of orb) {
              const childId = Number(c.id);
              selectedChildWordIds.add(childId);
              selectedChildWordLabels.set(childId, String(c.word || ""));
            }
            updateSelectionUI();
            renderReadTree();
          };
          body.appendChild(selectAllBtn);

          const ul = document.createElement("ul");
          for (const c of orb) {
            const li = document.createElement("li");
            const childId = Number(c.id);
            const on = selectedChildWordIds.has(childId);

            const b = document.createElement("button");
            b.type = "button";
            b.className = "pickbtn";
            b.textContent = on ? "✓" : "+";
            b.onclick = (ev) => {
              ev.stopPropagation();
              toggleChildSelection(childId, String(c.word || ""));
              if (!activeChildWordId || selectedChildWordIds.has(childId)) {
                setActiveChild(childId, { ensureSelected: true, pushUrl: true });
              }
            };

            const a = document.createElement("a");
            a.href = `stars.html?child_word_id=${encodeURIComponent(c.id)}`;
            a.className = "picklink";
            a.textContent = String(c.word || "");
            a.onclick = (ev) => {
              ev.preventDefault();
              selectedChildWordLabels.set(childId, String(c.word || ""));
              setActiveChild(childId, { ensureSelected: true, pushUrl: true });
            };

            let src = null;
            if (c.link) {
              src = document.createElement("a");
              src.href = c.link;
              src.target = "_blank";
              src.rel = "noopener noreferrer";
              src.className = "muted tiny";
              src.textContent = "source";
            }

            const row = document.createElement("span");
            row.className = "pickrow";
            row.appendChild(b);
            row.appendChild(a);
            if (src) {
              const dot = document.createElement("span");
              dot.className = "muted tiny";
              dot.textContent = "·";
              row.appendChild(dot);
              row.appendChild(src);
            }

            li.appendChild(row);
            ul.appendChild(li);
          }
          body.appendChild(ul);
        }

        if (!kids.length && !orb.length) {
          const p = document.createElement("div");
          p.className = "muted tiny";
          p.style.marginTop = "8px";
          p.textContent = "no children";
          body.appendChild(p);
        }
      } catch (e) {
        body.innerHTML = `<div class="card danger">${escapeHtml(String(e.message || e))}</div>`;
      }
    });

    if (nodeDetails.open && !loaded) {
      nodeDetails.dispatchEvent(new Event("toggle"));
    }

    hostEl.appendChild(nodeDetails);
  }

  async function loadWriteTree() {
    $("treeMeta").textContent = "loading…";
    const data = await apiGet("/api/write");
    roots = Array.isArray(data.roots) ? data.roots : [];

    nodeCache.clear();
    await refreshWordIndex();

    for (const R of roots) {
      const versions = Array.isArray(R.versions) ? R.versions : [];
      const latest = versions.length ? versions[0] : null;
      if (latest) {
        latestVersionByWordId.set(R.lang_word_id, latest.version_id);
        nodeCache.set(R.lang_word_id, {
          version_id: latest.version_id,
          version: latest.version,
          child_words: Array.isArray(latest.child_words) ? latest.child_words : [],
          child_lang_words: Array.isArray(latest.child_lang_words) ? latest.child_lang_words : [],
        });
      }
    }

    renderReadTree();
  }

  async function loadActiveChild() {
    const childId = activeChildWordId;
    if (!childId) {
      $("activePill").textContent = "child_word_id: —";
      $("childWord").textContent = "—";
      $("childLink").style.display = "none";
      $("langName").textContent = "—";
      $("langWord").textContent = "—";
      $("langWordMeta").textContent = "";
      $("ctxMeta").textContent = "pick a child word on the left";
      $("stuff").innerHTML = `<div class="muted tiny">No active child word.</div>`;
      $("meta").textContent = "—";
      updateManualStarEnabled();
      return;
    }

    $("activePill").textContent = `child_word_id: ${childId}`;
    const data = await apiGet(`/api/stars?child_word_id=${encodeURIComponent(childId)}`);

    const langName = data.lang_name && data.lang_name.word ? data.lang_name.word : "—";
    const langWord = data.lang_word && data.lang_word.word ? data.lang_word.word : "—";
    const langWordId = data.lang_word && data.lang_word.id ? data.lang_word.id : "—";
    const version = data.lang_word && data.lang_word.version ? data.lang_word.version : null;

    $("langName").textContent = langName;
    $("langWord").textContent = langWord;
    $("langWordMeta").textContent = version ? `(v${version} • id ${langWordId})` : (langWordId !== "—" ? `(id ${langWordId})` : "");
    $("childWord").textContent = (data.child_word && data.child_word.word) ? data.child_word.word : "—";
    $("ctxMeta").textContent = `lang_word_id ${langWordId}`;

    if (data.child_word && data.child_word.word) selectedChildWordLabels.set(childId, data.child_word.word);

    if (data.child_word && data.child_word.link) {
      $("childLink").style.display = "";
      $("childLink").href = data.child_word.link;
      $("childLink").textContent = "source";
    } else {
      $("childLink").style.display = "none";
    }

    renderStuff(data.star_stuff || []);
    updateManualStarEnabled();
  }

  function renderStuff(items) {
    $("meta").textContent = `${items.length} item(s)`;
    const host = $("stuff");
    host.innerHTML = "";
    const copyAllBtn = $("copyAllStuffBtn");
    if (copyAllBtn) {
      copyAllBtn.disabled = !items.length;
      copyAllBtn.onclick = async () => {
        if (!items.length) return;
        const all = items.map(it => {
          const header = `#${it.id} ${it.prompt_type}`;
          const texts = (Array.isArray(it.texts) && it.texts.length)
            ? it.texts
            : [{ id: null, text: it.text || "", created_at: it.created_at || "" }];
          const body = texts.map((t, idx) => {
            const head = `text ${idx + 1}${t.created_at ? ` • ${t.created_at}` : ""}`;
            return `${head}\n${String(t.text || "")}`.trim();
          }).join("\n\n---\n\n");
          return `${header}\n${body}`.trim();
        }).join("\n\n---\n\n");
        try {
          await copyTextToClipboard(all);
          copyAllBtn.textContent = "copied";
          setTimeout(() => { copyAllBtn.textContent = "copy all"; }, 1200);
        } catch (e) {
          alert(String(e.message || e));
        }
      };
    }
    if (!items.length) { host.innerHTML = `<div class="muted tiny">No star stuff yet for this child word.</div>`; return; }

    const groups = {};
    for (const it of items) {
      groups[it.prompt_type] = groups[it.prompt_type] || [];
      groups[it.prompt_type].push(it);
    }

    for (const [ptype, arr] of Object.entries(groups)) {
      const d = document.createElement("details");
      d.open = false;
      const s = document.createElement("summary");
      s.innerHTML = `<strong>${escapeHtml(ptype)}</strong> <span class="muted tiny">(${arr.length})</span>`;
      d.appendChild(s);

      for (const it of arr) {
        const card = document.createElement("div");
        card.className = "card";
        card.innerHTML = `
          <div class="row" style="justify-content:space-between;">
            <div><strong>#${it.id}</strong> <span class="muted tiny">task ${it.task_id ?? "—"} • ${escapeHtml(it.created_at || "")}</span></div>
            <span class="row">
              ${it.modifier ? `<span class="pill">modifier</span>` : `<span class="pill muted">no modifier</span>`}
              <button class="btn-sm" data-copy="1" type="button">copy</button>
            </span>
          </div>
          ${it.modifier ? `<div class="muted tiny" style="margin-top:6px;">${escapeHtml(it.modifier)}</div>` : ""}
        `;
        const texts = (Array.isArray(it.texts) && it.texts.length)
          ? it.texts
          : [{ id: null, text: it.text || "", created_at: it.created_at || "" }];
        const textHost = document.createElement("div");
        textHost.style.marginTop = "8px";
        texts.forEach((t, idx) => {
          const label = document.createElement("div");
          label.className = "muted tiny";
          label.textContent = `text ${idx + 1}${t.created_at ? ` • ${t.created_at}` : ""}`;
          const pre = document.createElement("pre");
          pre.textContent = String(t.text || "");
          textHost.appendChild(label);
          textHost.appendChild(pre);
        });
        card.appendChild(textHost);

        const addWrap = document.createElement("div");
        addWrap.style.marginTop = "10px";
        const addLabel = document.createElement("div");
        addLabel.className = "muted tiny";
        addLabel.textContent = "add text";
        const addTa = document.createElement("textarea");
        addTa.placeholder = "new text entry…";
        const addBtn = document.createElement("button");
        addBtn.type = "button";
        addBtn.textContent = "add text";
        addBtn.disabled = !adminOk;
        addBtn.onclick = async () => {
          const nextText = (addTa.value || "").trim();
          if (!nextText) return alert("Text is required.");
          try {
            addBtn.disabled = true;
            await apiPost(`/api/star_stuff/${it.id}/texts`, { text: nextText }, { admin: true });
            addTa.value = "";
            await loadActiveChild();
          } catch (e) {
            alert(String(e.message || e));
          } finally {
            addBtn.disabled = !adminOk;
          }
        };
        addWrap.appendChild(addLabel);
        addWrap.appendChild(addTa);
        addWrap.appendChild(addBtn);
        card.appendChild(addWrap);
        const copyBtn = card.querySelector('button[data-copy="1"]');
        if (copyBtn) {
          copyBtn.onclick = async () => {
            try {
              const payload = texts.map((t, idx) => {
                const head = `text ${idx + 1}${t.created_at ? ` • ${t.created_at}` : ""}`;
                return `${head}\n${String(t.text || "")}`.trim();
              }).join("\n\n---\n\n");
              await copyTextToClipboard(payload);
              copyBtn.textContent = "copied";
              setTimeout(() => { copyBtn.textContent = "copy"; }, 1200);
            } catch (e) {
              alert(String(e.message || e));
            }
          };
        }
        d.appendChild(card);
      }
      host.appendChild(d);
    }
  }

  // ---- Events
  $("searchInput").addEventListener("input", (e) => {
    searchTerm = (e.target.value || "").toLowerCase();
    renderReadTree();
  });

  $("refreshTreeBtn").onclick = () => loadWriteTree();

  $("clearSelectionBtn").onclick = () => {
    selectedChildWordIds.clear();
    selectedChildWordLabels.clear();
    activeChildWordId = null;
    setUrlChildWordId(null);
    updateSelectionUI();
    loadActiveChild();
    renderReadTree();
  };

  $("refreshBtn").onclick = async () => {
    await refreshAdminStatus();
    await loadActiveChild();
  };

  $("runBtn").onclick = async () => {
    const prompts = selectedPrompts();
    if (!prompts.length) { alert("Select at least one prompt."); return; }

    const ids = Array.from(selectedChildWordIds);
    if (!ids.length) { alert("Select at least one child word."); return; }

    try {
      $("runBtn").disabled = true;
      $("taskPill").textContent = `queued (${ids.length} child word${ids.length === 1 ? "" : "s"})`;

      const modifier = ($("modifierInput").value || "").trim();

      const allTaskIds = [];
      let idx = 0;
      for (const childId of ids) {
        idx += 1;
        $("taskPill").textContent = `queueing ${idx}/${ids.length}`;
        const res = await apiPost("/api/star_stuff/tasks", { child_word_id: childId, prompts, modifier }, { admin: true });
        const taskIds = (res && res.task_ids) ? res.task_ids : [];
        for (const t of taskIds) allTaskIds.push(t);
      }

      if (!allTaskIds.length) {
        $("taskPill").textContent = "done (no tasks?)";
      } else {
        let j = 0;
        for (const t of allTaskIds) {
          j += 1;
          $("taskPill").textContent = `running ${j}/${allTaskIds.length}`;
          await pollTask(t);
        }
        $("taskPill").textContent = "done";
      }

      await loadActiveChild();
    } catch (e) {
      $("taskPill").textContent = "error";
      alert(String(e.message || e));
    } finally {
      $("runBtn").disabled = !(getAdminKey() && selectedChildWordIds.size > 0);
    }
  };

  $("manualCreateBtn").onclick = async () => {
    if (!activeChildWordId) return alert("Select an active child word.");
    if (!getAdminKey()) return alert("Admin key required.");
    const promptType = ($("manualPromptTypeInput").value || "").trim();
    const text = ($("manualTextInput").value || "").trim();
    const model = ($("manualModelInput").value || "").trim();
    const modifier = ($("manualModifierInput").value || "").trim();
    if (!promptType) return alert("Prompt type is required.");
    if (!text) return alert("Text is required.");
    try {
      $("manualCreateBtn").disabled = true;
      await apiPost("/api/star_stuff/manual", {
        child_word_id: activeChildWordId,
        prompt_type: promptType,
        text,
        model,
        modifier
      }, { admin: true });
      $("manualTextInput").value = "";
      await loadActiveChild();
    } catch (e) {
      alert(String(e.message || e));
    } finally {
      updateManualStarEnabled();
    }
  };

  window.addEventListener("popstate", () => {
    const childId = getChildWordIdFromUrl();
    if (childId) setActiveChild(childId, { ensureSelected: true, pushUrl: false });
    else {
      activeChildWordId = null;
      updateSelectionUI();
      loadActiveChild();
    }
  });

  async function boot() {
    const searchParam = (new URL(location.href)).searchParams.get("search");
    if (searchParam) {
      $("searchInput").value = searchParam;
      searchTerm = String(searchParam || "").toLowerCase();
    }
    await refreshAdminStatus();
    await loadWriteTree();

    const urlChildId = getChildWordIdFromUrl();
    if (urlChildId) {
      selectedChildWordIds.add(urlChildId);
      activeChildWordId = urlChildId;
      setUrlChildWordId(urlChildId, { replace: true });
      updateSelectionUI();
      await loadActiveChild();
    } else {
      updateSelectionUI();
      await loadActiveChild();
    }
  }

  boot().catch(err => {
    console.error(err);
    $("stuff").innerHTML = `<div class="card danger">${escapeHtml(String(err.message || err))}</div>`;
  });
</script>
</body>
</html>
