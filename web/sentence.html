<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>sentence</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin: 0; line-height: 1.4; }
    header { padding: 14px 16px; border-bottom: 1px solid color-mix(in oklab, currentColor 22%, transparent); display:flex; gap:12px; align-items:baseline; justify-content:space-between; }
    header h1 { font-size: 18px; margin: 0; }
    header nav a { margin-right: 10px; }
    a { text-decoration: none; border-bottom: 1px solid currentColor; }
    main { max-width: 76rem; margin: 0 auto; padding: 16px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .muted { opacity: .75; }
    .pill { display:inline-block; border: 1px solid color-mix(in oklab, currentColor 60%, transparent); border-radius: 999px; padding: 2px 10px; font-size: 12px; }
    button { font: inherit; padding: 8px 10px; border-radius: 10px; border: 1px solid color-mix(in oklab, currentColor 30%, transparent); background: transparent; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    input { font: inherit; padding: 8px 10px; border-radius: 10px; border: 1px solid color-mix(in oklab, currentColor 30%, transparent); background: transparent; }
    details { border: 1px solid color-mix(in oklab, currentColor 18%, transparent); border-radius: 14px; padding: 10px 12px; margin: 10px 0; }
    details details { margin: 8px 0 0; }
    summary { cursor: pointer; user-select: none; }
    ul { margin: 8px 0; padding-left: 18px; }
    li { margin: 4px 0; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }
    .card { border: 1px solid color-mix(in oklab, currentColor 18%, transparent); border-radius: 14px; padding: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .tiny { font-size: 12px; }
    .loading { opacity: .8; font-style: italic; }
    .indent { margin-left: 14px; border-left: 2px solid color-mix(in oklab, currentColor 12%, transparent); padding-left: 12px; }

    .overlay { position: fixed; inset: 0; background: color-mix(in oklab, black 35%, transparent); display:none; align-items:stretch; justify-content:flex-end; }
    .panel { width: min(520px, 92vw); background: Canvas; border-left: 1px solid color-mix(in oklab, currentColor 18%, transparent); padding: 14px; overflow:auto; }
    .panel h2 { font-size: 14px; margin: 0 0 10px 0; }
    .list { margin-top:10px; max-height: 60vh; overflow:auto; border: 1px solid color-mix(in oklab, currentColor 18%, transparent); border-radius: 12px; padding: 8px; }
    .list-item { display:flex; align-items:center; justify-content:space-between; gap:10px; padding: 6px 6px; border-radius: 10px; }
    .list-item:hover { background: color-mix(in oklab, currentColor 7%, transparent); }
    .btn-sm { padding: 4px 8px; font-size: 12px; border-radius: 10px; }
    .danger { border-color: color-mix(in oklab, red 35%, currentColor 18%); }
    textarea { width:100%; min-height:84px; }
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    @media (max-width: 980px) { .grid3 { grid-template-columns: 1fr; } }
    .toggle { display:flex; align-items:center; gap:8px; font-size:12px; }
    .toggle input { width: 40px; height: 20px; appearance: none; background: color-mix(in oklab, currentColor 18%, transparent); border-radius: 999px; position: relative; border: 1px solid color-mix(in oklab, currentColor 30%, transparent); }
    .toggle input::after { content: ""; position: absolute; top: 1px; left: 1px; width: 16px; height: 16px; border-radius: 50%; background: currentColor; transition: transform .2s ease; }
    .toggle input:checked::after { transform: translateX(20px); }

  </style>
</head>
<body>
<header>
  <div class="row">
    <h1>sentence</h1>
    <span class="pill" id="metaPill">…</span>
  </div>
  <nav class="tiny">
    <a href="./">home</a>
    <a href="write.html">write</a>
    <a href="lang.html">sentences</a>
  </nav>
  <div class="row tiny" style="justify-content:flex-end; margin-top:8px;">
    <span class="muted" id="adminStatus">admin: unknown</span>
  </div>
</header>

<main>
  <div class="grid">
    <section class="card">
      <div class="row" style="justify-content:space-between;">
        <strong>sentence</strong>
        <div class="row">
          <label class="toggle muted">
            <span>child words only</span>
            <input id="childWordsToggle" type="checkbox" />
          </label>
          <input id="sentenceIdInput" placeholder="sentence id…" style="width:140px;" />
          <button id="goBtn" type="button">open</button>
          <button id="editWordsBtn" type="button" disabled>edit words</button>
        </div>
      </div>
      <div class="muted tiny" id="sentenceMeta">…</div>
      <div style="margin-top:10px;" id="sentenceText" class="mono"></div>
      <div style="margin-top:10px;" class="muted tiny mono" id="sentenceIds"></div>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between;">
        <strong>lang words</strong>
        <span class="muted tiny" id="wordsMeta">…</span>
      </div>
      <div id="wordsHost" style="margin-top:10px;"></div>
      <div style="margin-top:12px;">
        <div class="row" style="justify-content:space-between;">
          <strong class="tiny">child words</strong>
          <span class="muted tiny" id="childWordsMeta">—</span>
        </div>
        <div id="childWordsHost" style="margin-top:6px;"></div>
      </div>
    </section>

    <section class="card" style="grid-column: 1 / -1;">
      <div class="row" style="justify-content:space-between;">
        <strong>child sentences</strong>
        <span class="muted tiny" id="childMeta">…</span>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row" style="justify-content:space-between;">
          <strong class="tiny">create child sentence</strong>
          <div class="row">
            <button id="autoChildSentenceBtn" type="button" disabled>auto create</button>
            <button id="clearChildSentenceBtn" type="button">clear</button>
            <button id="createChildSentenceBtn" type="button" disabled>create</button>
          </div>
        </div>
        <div class="muted tiny" id="childCreateHint">requires admin key; select ids and enter sentence text</div>
        <div class="muted tiny" id="childAutoStatus"></div>

        <div class="grid3" style="margin-top:10px;">
          <div>
            <div class="row" style="justify-content:space-between;">
              <strong class="tiny">parent lang words</strong>
              <span class="muted tiny" id="parentSelMeta">0</span>
            </div>
            <div id="parentPick" class="list"></div>
          </div>
          <div>
            <div class="row" style="justify-content:space-between;">
              <strong class="tiny">child lang words</strong>
              <span class="muted tiny" id="childLangSelMeta">0</span>
            </div>
            <div id="childLangPick" class="list"></div>
          </div>
          <div>
            <div class="row" style="justify-content:space-between;">
              <strong class="tiny">child words</strong>
              <span class="muted tiny" id="childWordSelMeta">0</span>
            </div>
            <div id="childWordPick" class="list"></div>
          </div>
        </div>

        <div style="margin-top:10px;">
          <textarea id="childSentenceText" placeholder="child sentence text…"></textarea>
        </div>
      </div>

      <div id="childSentenceList" style="margin-top:12px;"></div>
    </section>

  </div>
</main>


<div class="overlay" id="wordPickerOverlay" role="dialog" aria-modal="true">
  <div class="panel">
    <div class="row" style="justify-content:space-between;">
      <h2>add lang words</h2>
      <button id="closeWordPickerBtn" type="button">close</button>
    </div>
    <div class="muted tiny" id="wordPickerHint">search and click add</div>
    <div style="margin-top:10px;" class="row">
      <input id="wordPickerSearch" placeholder="search lang words…" style="flex:1; min-width:200px;" />
      <button id="wordPickerRefreshBtn" type="button">refresh</button>
    </div>
    <div class="list" id="wordPickerList"></div>
  </div>
</div>

<div class="overlay" id="tempWritingsOverlay" role="dialog" aria-modal="true">
  <div class="panel">
    <div class="row" style="justify-content:space-between;">
      <div>
        <h2 style="margin:0;">temporary writings</h2>
        <div class="muted tiny" id="tempWritingsTitle">—</div>
      </div>
      <div class="row">
        <button id="refreshTempWritingsBtn" type="button">refresh</button>
        <button id="closeTempWritingsBtn" type="button">close</button>
      </div>
    </div>
    <div class="muted tiny" id="tempWritingsMeta">—</div>
    <div class="list" id="tempWritingsList" style="margin-top:10px;"></div>
  </div>
</div>

<script>
  const $ = (id) => document.getElementById(id);

  function esc(s) {
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function getAdminKey() {
    return localStorage.getItem("lang_admin_key") || "";
  }
  function setAdminKey(v) {
    localStorage.setItem("lang_admin_key", v);
  }
  function updateAdminStatus() {
    const has = !!getAdminKey();
    $("adminStatus").textContent = has ? "admin: set" : "admin: not set";
    $("editWordsBtn").disabled = !(has && currentSentenceId);
    updateCreateChildEnabled();
    updateAutoChildEnabled();
  }

  function getParam(name) {
    const u = new URL(window.location.href);
    return u.searchParams.get(name);
  }
  function setParam(name, value) {
    const u = new URL(window.location.href);
    if (value === null || value === undefined || value === "") u.searchParams.delete(name);
    else u.searchParams.set(name, value);
    history.replaceState({}, "", u.toString());
  }

  async function apiGet(url) {
    const headers = { "Accept": "application/json" };
    const k = getAdminKey();
    if (k) headers["X-Admin-Key"] = k;
    const res = await fetch(url, { headers });
    if (!res.ok) throw new Error(`GET ${url} failed (${res.status})`);
    return await res.json();
  }

  async function apiJson(method, url, body) {
    const headers = { "Accept": "application/json", "Content-Type": "application/json" };
    const k = getAdminKey();
    if (k) headers["X-Admin-Key"] = k;
    const res = await fetch(url, { method, headers, body: body ? JSON.stringify(body) : undefined });
    if (!res.ok) {
      let msg = `${method} ${url} failed (${res.status})`;
      try {
        const j = await res.json();
        if (j && (j.error || j.message)) msg += `: ${j.error || j.message}`;
      } catch {}
      throw new Error(msg);
    }
    return await res.json();
  }
  const apiPost = (url, body) => apiJson("POST", url, body);
  const apiPut  = (url, body) => apiJson("PUT", url, body);

  let wordsIndex = new Map(); // lang_word_id -> {word, latest_version_id, ...}
  const versionCache = new Map(); // version_id -> version payload
  let currentSentenceId = null;
  let currentChildSentenceId = null;
  let currentLangWordIds = [];
  let selectedTempLangWordId = null;
  let autoChildRunning = false;
  let childWordsOnlyMode = false;

  // child sentence pick state
  let selectedParent = new Set();
  let selectedChildLang = new Set();
  let selectedChildWord = new Set();

  async function loadWordsIndex() {
    const data = await apiGet("/api/lang_words");
    const arr = Array.isArray(data.words) ? data.words : [];
    wordsIndex = new Map(arr.map(w => [Number(w.lang_word_id), w]));
  }

  async function saveSentenceLangWords(newIds) {
    if (!currentSentenceId) return;
    await apiPut(`/api/lang_sentences/${currentSentenceId}`, { lang_word_ids: newIds });
  }

  async function removeLangWordFromSentence(langWordId) {
    if (!getAdminKey()) return alert("Admin key required.");
    const idn = Number(langWordId);
    const next = currentLangWordIds.filter(x => Number(x) !== idn);
    await saveSentenceLangWords(next);
    await loadSentence(currentSentenceId);
  }

  async function addLangWordToSentence(langWordId) {
    if (!getAdminKey()) return alert("Admin key required.");
    const idn = Number(langWordId);
    if (!Number.isFinite(idn)) return;
    const set = new Set(currentLangWordIds.map(Number));
    set.add(idn);
    const next = Array.from(set.values()).sort((a,b) => a-b);
    await saveSentenceLangWords(next);
    await loadSentence(currentSentenceId);
  }

  async function loadSentence(sentenceId) {
    setChildWordsToggle(false);
    $("metaPill").textContent = `#${sentenceId}`;
    $("sentenceMeta").textContent = "loading…";
    $("sentenceText").innerHTML = `<span class="loading">loading…</span>`;
    $("sentenceIds").textContent = "";
    $("wordsHost").innerHTML = "";
    $("childWordsHost").innerHTML = "";
    $("childWordsMeta").textContent = "—";
    $("childSentenceList").innerHTML = "";
    $("childAutoStatus").textContent = "";

    const s = await apiGet(`/api/lang_sentences/${sentenceId}`);
    const ids = Array.isArray(s.lang_word_ids) ? s.lang_word_ids : [];
    const idsInt = ids.map(x => Number(x)).filter(x => Number.isFinite(x));

    currentSentenceId = Number(sentenceId);
    currentChildSentenceId = null;
    currentLangWordIds = idsInt;
    autoChildRunning = false;
    childWordsOnlyMode = false;

    $("sentenceMeta").textContent = `updated ${s.updated_at || ""}`;
    $("sentenceText").innerHTML = esc(s.sentence || "");
    $("sentenceIds").innerHTML = `lang_word_ids: ${esc(JSON.stringify(idsInt))}`;
    $("sentenceIdInput").value = String(sentenceId);

    $("wordsMeta").textContent = `${idsInt.length} word(s)`;
    $("wordsHost").innerHTML = "";

    for (const wid of idsInt) {
      const node = renderLangWordNode(Number(wid), 0);
      $("wordsHost").appendChild(node);
    }

    if (!idsInt.length) {
      const p = document.createElement("div");
      p.className = "muted tiny";
      p.textContent = "no lang words linked to this sentence";
      $("wordsHost").appendChild(p);
    }

    renderParentPick();
    await refreshChildPicks();
    await loadChildSentences();
    updateAdminStatus();
  }

  async function loadChildWordsOnly(sentenceId) {
    setChildWordsToggle(true);
    $("metaPill").textContent = `#${sentenceId} child words`;
    $("sentenceMeta").textContent = "loading…";
    $("sentenceText").innerHTML = `<span class="loading">loading…</span>`;
    $("sentenceIds").textContent = "";
    $("wordsHost").innerHTML = "";
    $("childWordsHost").innerHTML = "";
    $("childWordsMeta").textContent = "—";
    $("childSentenceList").innerHTML = "";
    $("childAutoStatus").textContent = "";

    const s = await apiGet(`/api/lang_sentences/${sentenceId}`);
    currentSentenceId = Number(sentenceId);
    currentChildSentenceId = null;
    currentLangWordIds = Array.isArray(s.lang_word_ids) ? s.lang_word_ids : [];
    autoChildRunning = false;
    childWordsOnlyMode = true;

    $("sentenceMeta").textContent = `child words only • updated ${s.updated_at || ""}`;
    $("sentenceText").innerHTML = esc(s.sentence || "");
    $("sentenceIds").innerHTML = `lang_word_ids: ${esc(JSON.stringify(currentLangWordIds))}`;
    $("sentenceIdInput").value = String(sentenceId);

    const langIds = currentLangWordIds.map(x => Number(x)).filter(x => Number.isFinite(x));
    $("wordsMeta").textContent = `${langIds.length} word(s)`;
    $("wordsHost").innerHTML = "";

    for (const wid of langIds) {
      const node = renderLangWordNode(Number(wid), 0);
      $("wordsHost").appendChild(node);
    }

    if (!langIds.length) {
      const p = document.createElement("div");
      p.className = "muted tiny";
      p.textContent = "no lang words linked to this sentence";
      $("wordsHost").appendChild(p);
    }

    const data = await apiGet(`/api/lang_sentences/${sentenceId}/child_sentences`);
    const arr = Array.isArray(data.child_sentences) ? data.child_sentences : [];
    const allChildIds = new Set();
    for (const cs of arr) {
      const cw = Array.isArray(cs.child_word_ids) ? cs.child_word_ids : [];
      for (const id of cw) {
        const idn = Number(id);
        if (Number.isFinite(idn)) allChildIds.add(idn);
      }
    }

    await renderChildWordsByIds(Array.from(allChildIds.values()).sort((a,b) => a-b));
    $("childMeta").textContent = "child words only";
    $("childSentenceList").innerHTML = `<div class="muted tiny">${arr.length} child sentence(s) scanned</div>`;
    updateAdminStatus();
    updateCreateChildEnabled();
  }

  async function loadChildSentence(childSentenceId) {
    setChildWordsToggle(false);
    $("metaPill").textContent = `child #${childSentenceId}`;
    $("sentenceMeta").textContent = "loading…";
    $("sentenceText").innerHTML = `<span class="loading">loading…</span>`;
    $("sentenceIds").textContent = "";
    $("wordsHost").innerHTML = "";
    $("childWordsHost").innerHTML = "";
    $("childWordsMeta").textContent = "—";
    $("childSentenceList").innerHTML = "";
    $("childAutoStatus").textContent = "";

    const cs = await apiGet(`/api/child_sentences/${childSentenceId}`);
    const lw = Array.isArray(cs.lang_word_ids) ? cs.lang_word_ids : [];
    const cw = Array.isArray(cs.child_word_ids) ? cs.child_word_ids : [];
    const langIds = lw.map(x => Number(x)).filter(x => Number.isFinite(x));
    const childIds = cw.map(x => Number(x)).filter(x => Number.isFinite(x));

    currentSentenceId = null;
    currentChildSentenceId = Number(childSentenceId);
    currentLangWordIds = langIds;
    autoChildRunning = false;
    childWordsOnlyMode = false;

    $("sentenceMeta").textContent = `child sentence • updated ${cs.updated_at || ""}`;
    $("sentenceText").innerHTML = esc(cs.sentence || "");
    $("sentenceIds").innerHTML = `lang_word_ids: ${esc(JSON.stringify(langIds))} • child_word_ids: ${esc(JSON.stringify(childIds))}`;
    $("sentenceIdInput").value = "";

    $("wordsMeta").textContent = `${langIds.length} word(s)`;
    $("wordsHost").innerHTML = "";

    for (const wid of langIds) {
      const node = renderLangWordNode(Number(wid), 0);
      $("wordsHost").appendChild(node);
    }

    if (!langIds.length) {
      const p = document.createElement("div");
      p.className = "muted tiny";
      p.textContent = "no lang words linked to this child sentence";
      $("wordsHost").appendChild(p);
    }

    await renderChildWordsByIds(childIds);

    $("childMeta").textContent = "child sentence view";
    $("childSentenceList").innerHTML = `<div class="muted tiny">open a parent sentence to view child sentences</div>`;
    updateAdminStatus();
    updateCreateChildEnabled();
  }

  async function loadChildSentenceWordsOnly(childSentenceId) {
    setChildWordsToggle(true);
    $("metaPill").textContent = `child #${childSentenceId} words`;
    $("sentenceMeta").textContent = "loading…";
    $("sentenceText").innerHTML = `<span class="loading">loading…</span>`;
    $("sentenceIds").textContent = "";
    $("wordsHost").innerHTML = "";
    $("childWordsHost").innerHTML = "";
    $("childWordsMeta").textContent = "—";
    $("childSentenceList").innerHTML = "";
    $("childAutoStatus").textContent = "";

    const cs = await apiGet(`/api/child_sentences/${childSentenceId}`);
    const lw = Array.isArray(cs.lang_word_ids) ? cs.lang_word_ids : [];
    const cw = Array.isArray(cs.child_word_ids) ? cs.child_word_ids : [];
    const langIds = lw.map(x => Number(x)).filter(x => Number.isFinite(x));
    const childIds = cw.map(x => Number(x)).filter(x => Number.isFinite(x));

    currentSentenceId = null;
    currentChildSentenceId = Number(childSentenceId);
    currentLangWordIds = langIds;
    autoChildRunning = false;
    childWordsOnlyMode = true;

    $("sentenceMeta").textContent = `child sentence • updated ${cs.updated_at || ""}`;
    $("sentenceText").innerHTML = esc(cs.sentence || "");
    $("sentenceIds").innerHTML = `lang_word_ids: ${esc(JSON.stringify(langIds))} • child_word_ids: ${esc(JSON.stringify(childIds))}`;
    $("sentenceIdInput").value = "";

    $("wordsMeta").textContent = `${langIds.length} word(s)`;
    $("wordsHost").innerHTML = "";

    for (const wid of langIds) {
      const node = renderLangWordNode(Number(wid), 0);
      $("wordsHost").appendChild(node);
    }

    if (!langIds.length) {
      const p = document.createElement("div");
      p.className = "muted tiny";
      p.textContent = "no lang words linked to this child sentence";
      $("wordsHost").appendChild(p);
    }
    await renderChildWordsByIds(childIds);

    $("childMeta").textContent = "child words only";
    $("childSentenceList").innerHTML = `<div class="muted tiny">child sentence view</div>`;
    updateAdminStatus();
    updateCreateChildEnabled();
  }

  function renderLangWordNode(langWordId, depth) {
    const w = wordsIndex.get(langWordId);
    const label = w ? `${w.word} (id ${langWordId})` : `lang_word_id ${langWordId}`;
    const latestVersionId = w ? w.latest_version_id : null;
    const starsHref = w && w.word ? `stars.html?search=${encodeURIComponent(w.word)}` : "stars.html";

    const det = document.createElement("details");
    det.dataset.langWordId = String(langWordId);
    det.dataset.depth = String(depth);

    const sum = document.createElement("summary");
    const rmBtnHtml = (getAdminKey() && currentSentenceId)
      ? `<button class="btn-sm danger" data-remove="1" type="button">remove</button>`
      : "";
    const tempBtnsHtml = `
      <button class="btn-sm" data-temp-create="1" type="button">create temp</button>
      <button class="btn-sm" data-temp-open="1" type="button">temp writings</button>
      <a class="btn-sm" href="${starsHref}" target="_blank" rel="noopener noreferrer">stars</a>
    `;
    sum.innerHTML = `
      <span class="row" style="justify-content:space-between; width:100%;">
        <span><strong>${esc(label)}</strong> <span class="muted tiny">${esc(latestVersionId ? `v_id ${latestVersionId}` : "no version")}</span></span>
        <span class="row">${tempBtnsHtml}${rmBtnHtml}</span>
      </span>
    `;
    det.appendChild(sum);

    const rm = sum.querySelector('button[data-remove]');
    if (rm) {
      rm.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        removeLangWordFromSentence(langWordId).catch(err => alert(err.message || err));
      });
    }
    const tempCreate = sum.querySelector('button[data-temp-create]');
    if (tempCreate) {
      tempCreate.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        createTempWriting(langWordId).catch(err => alert(err.message || err));
      });
    }
    const tempOpen = sum.querySelector('button[data-temp-open]');
    if (tempOpen) {
      tempOpen.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        openTempWritings(langWordId).catch(err => alert(err.message || err));
      });
    }

    const inner = document.createElement("div");
    inner.className = depth ? "indent" : "";
    inner.innerHTML = `<div class="loading">expand to load…</div>`;
    det.appendChild(inner);

    let loaded = false;
    det.addEventListener("toggle", async () => {
      if (!det.open || loaded) return;
      loaded = true;

      if (!latestVersionId) {
        inner.innerHTML = `<div class="muted tiny">no version data</div>`;
        return;
      }

      try {
        inner.innerHTML = `<div class="loading">loading children…</div>`;
        let v = versionCache.get(latestVersionId);
        if (!v) {
          v = await apiGet(`/api/lang_words/${latestVersionId}`);
          versionCache.set(latestVersionId, v);
        }

        const childLang = Array.isArray(v.child_lang_words) ? v.child_lang_words : [];
        const childWords = Array.isArray(v.child_words) ? v.child_words : [];

        const wrap = document.createElement("div");
        wrap.className = "grid";
        wrap.style.gridTemplateColumns = childWordsOnlyMode ? "1fr" : "1fr 1fr";

        if (!childWordsOnlyMode) {
          const sectionA = document.createElement("div");
          sectionA.innerHTML = `<strong class="tiny">child lang words</strong>`;
          if (childLang.length) {
            const ul = document.createElement("ul");
            ul.className = "tiny";
            for (const c of childLang) {
              const li = document.createElement("li");
              li.innerHTML = `${esc(c.word)} <span class="muted">(#${esc(c.lang_word_id)})</span>`;
              ul.appendChild(li);
            }
            sectionA.appendChild(ul);
          } else {
            const p = document.createElement("div");
            p.className = "muted tiny";
            p.textContent = "none";
            sectionA.appendChild(p);
          }
          wrap.appendChild(sectionA);
        }

        const sectionB = document.createElement("div");
        sectionB.innerHTML = `<strong class="tiny">child words</strong>`;
        if (childWords.length) {
          const ul = document.createElement("ul");
          ul.className = "tiny";
          for (const c of childWords) {
            const li = document.createElement("li");
            const link = c.link ? ` • <a href="${esc(c.link)}" target="_blank" rel="noopener noreferrer">link</a>` : "";
            li.innerHTML = `<span>${esc(c.word)} <span class="muted">(#${esc(c.id)})</span>${link}</span> • <a href="stars.html?child_word_id=${encodeURIComponent(c.id)}">stars</a>`;
            ul.appendChild(li);
          }
          sectionB.appendChild(ul);
        } else {
          const p = document.createElement("div");
          p.className = "muted tiny";
          p.textContent = "none";
          sectionB.appendChild(p);
        }

        wrap.appendChild(sectionB);
        inner.innerHTML = "";
        inner.appendChild(wrap);
      } catch (e) {
        inner.innerHTML = `<div class="muted tiny">error: ${esc(e.message || e)}</div>`;
      }
    });

    return det;
  }

  // ---------- word picker panel ----------
  function openWordPicker() {
    $("wordPickerOverlay").style.display = "flex";
    $("wordPickerSearch").value = "";
    renderWordPickerList();
    $("wordPickerSearch").focus();
  }
  function closeWordPicker() {
    $("wordPickerOverlay").style.display = "none";
  }
  function renderWordPickerList() {
    const q = ($("wordPickerSearch").value || "").trim().toLowerCase();
    const host = $("wordPickerList");
    host.innerHTML = "";
    const already = new Set(currentLangWordIds.map(Number));

    const items = Array.from(wordsIndex.values())
      .filter(w => {
        if (!q) return true;
        const s = String(w.word || "").toLowerCase();
        return s.includes(q) || String(w.lang_word_id).includes(q);
      })
      .slice(0, 500);

    for (const w of items) {
      const row = document.createElement("div");
      row.className = "list-item";
      const left = document.createElement("div");
      left.innerHTML = `<strong>${esc(w.word)}</strong> <span class="muted tiny">id ${esc(w.lang_word_id)}</span>`;
      const btn = document.createElement("button");
      btn.className = "btn-sm";
      if (already.has(Number(w.lang_word_id))) {
        btn.textContent = "added";
        btn.disabled = true;
      } else {
        btn.textContent = "add";
        btn.onclick = () => addLangWordToSentence(w.lang_word_id).catch(e => alert(e.message || e));
      }
      row.appendChild(left);
      row.appendChild(btn);
      host.appendChild(row);
    }
    if (!items.length) host.innerHTML = `<div class="muted tiny">no matches</div>`;
  }

  // ---------- temporary writings ----------
  async function createTempWriting(langWordId) {
    if (!getAdminKey()) return alert("Admin key required.");
    const w = wordsIndex.get(Number(langWordId));
    const label = w ? `${w.word} (#${langWordId})` : `lang_word_id ${langWordId}`;
    if (!confirm(`Enqueue temporary writings for ${label}?`)) return;
    await apiPost("/api/write/create_lang_words", { parent_lang_word_id: Number(langWordId), modifier: "" });
    alert("queued");
  }

  async function openTempWritings(langWordId) {
    if (!getAdminKey()) return alert("Admin key required.");
    selectedTempLangWordId = Number(langWordId);
    const w = wordsIndex.get(Number(langWordId));
    $("tempWritingsTitle").textContent = w ? `${w.word} (#${langWordId})` : `lang_word_id ${langWordId}`;
    $("tempWritingsOverlay").style.display = "flex";
    await loadTempWritings();
  }
  function closeTempWritings() {
    $("tempWritingsOverlay").style.display = "none";
  }
  async function loadTempWritings() {
    const host = $("tempWritingsList");
    host.innerHTML = "";
    if (!selectedTempLangWordId) return;
    try {
      const data = await apiGet(`/api/temporary_writings?parent_lang_word_id=${selectedTempLangWordId}`);
      const arr = Array.isArray(data.writings) ? data.writings : [];
      $("tempWritingsMeta").textContent = `${arr.length} writing(s)`;

      for (const w of arr) {
        const card = document.createElement("div");
        card.className = "card";

        const top = document.createElement("div");
        top.className = "row";
        top.style.justifyContent = "space-between";
        top.innerHTML = `<div><strong>writing #${w.id}</strong> <span class="muted tiny">task ${w.task_id ?? "—"} • ${esc(w.created_at || "")}</span></div>`;
        card.appendChild(top);

        const pre = document.createElement("pre");
        pre.textContent = JSON.stringify(w.text, null, 2);
        card.appendChild(pre);

        const btnRow = document.createElement("div");
        btnRow.className = "row";
        btnRow.style.marginTop = "10px";

        const applyBtn = document.createElement("button");
        applyBtn.type = "button";
        applyBtn.textContent = "create writing (apply)";
        applyBtn.onclick = async () => {
          if (!confirm("Apply this writing? This will create a NEW parent version and link ONLY the new themes.")) return;
          try {
            applyBtn.disabled = true;
            await apiPost(`/api/temporary_writings/${w.id}/apply_create_lang_words`, {});
            await loadTempWritings();
            await loadSentence(currentSentenceId);
          } catch (e) {
            alert(String(e.message || e));
          } finally {
            applyBtn.disabled = false;
          }
        };

        btnRow.appendChild(applyBtn);
        card.appendChild(btnRow);
        host.appendChild(card);
      }

      if (!arr.length) host.innerHTML = `<div class="muted tiny">no temporary writings yet</div>`;
    } catch (e) {
      $("tempWritingsMeta").textContent = "error";
      const p = document.createElement("div");
      p.className = "card danger";
      p.textContent = String(e.message || e);
      host.appendChild(p);
    }
  }

  // ---------- child sentence creation ----------
  function renderPick(hostId, items, selectedSet, onChange) {
    const host = $(hostId);
    host.innerHTML = "";
    for (const it of items) {
      const row = document.createElement("div");
      row.className = "list-item";
      const lab = document.createElement("label");
      lab.style.display = "flex";
      lab.style.gap = "8px";
      lab.style.alignItems = "center";
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = selectedSet.has(it.id);
      cb.onchange = () => onChange(it.id, cb.checked);
      const txt = document.createElement("span");
      txt.innerHTML = `${esc(it.label)} <span class="muted tiny">id ${esc(it.id)}</span>`;
      lab.appendChild(cb);
      lab.appendChild(txt);
      row.appendChild(lab);
      host.appendChild(row);
    }
    if (!items.length) host.innerHTML = `<div class="muted tiny">none</div>`;
  }

  function renderParentPick() {
    selectedParent = new Set(); // default: none selected
    $("parentSelMeta").textContent = String(selectedParent.size);
    const items = currentLangWordIds.map(id => {
      const w = wordsIndex.get(Number(id));
      return { id: Number(id), label: w ? w.word : `lang_word ${id}` };
    });
    renderPick("parentPick", items, selectedParent, async (id, checked) => {
      if (checked) selectedParent.add(Number(id));
      else selectedParent.delete(Number(id));
      $("parentSelMeta").textContent = String(selectedParent.size);
      await refreshChildPicks();
    });
  }

  async function refreshChildPicks() {
    selectedChildLang = new Set();
    selectedChildWord = new Set();
    $("childLangSelMeta").textContent = "0";
    $("childWordSelMeta").textContent = "0";

    const childLangMap = new Map();
    const childWordMap = new Map();

    for (const pid of selectedParent) {
      const w = wordsIndex.get(Number(pid));
      const vId = w ? w.latest_version_id : null;
      if (!vId) continue;

      let v = versionCache.get(vId);
      if (!v) {
        try {
          v = await apiGet(`/api/lang_words/${vId}`);
          versionCache.set(vId, v);
        } catch {}
      }
      if (!v) continue;

      const cl = Array.isArray(v.child_lang_words) ? v.child_lang_words : [];
      const cw = Array.isArray(v.child_words) ? v.child_words : [];

      for (const x of cl) {
        const id = Number(x.lang_word_id);
        if (!Number.isFinite(id)) continue;
        childLangMap.set(id, x.word || `lang_word ${id}`);
      }
      for (const x of cw) {
        const id = Number(x.id);
        if (!Number.isFinite(id)) continue;
        childWordMap.set(id, x.word || `child_word ${id}`);
      }
    }

    const childLangItems = Array.from(childLangMap.entries()).map(([id, word]) => ({ id, label: word }));
    const childWordItems = Array.from(childWordMap.entries()).map(([id, word]) => ({ id, label: word }));

    renderPick("childLangPick", childLangItems, selectedChildLang, (id, checked) => {
      if (checked) selectedChildLang.add(Number(id));
      else selectedChildLang.delete(Number(id));
      $("childLangSelMeta").textContent = String(selectedChildLang.size);
      updateCreateChildEnabled();
    });

    renderPick("childWordPick", childWordItems, selectedChildWord, (id, checked) => {
      if (checked) selectedChildWord.add(Number(id));
      else selectedChildWord.delete(Number(id));
      $("childWordSelMeta").textContent = String(selectedChildWord.size);
      updateCreateChildEnabled();
    });

    updateCreateChildEnabled();
  }

  function updateCreateChildEnabled() {
    const textOk = (($("childSentenceText").value || "").trim().length > 0);
    const anyIds = (selectedParent.size + selectedChildLang.size + selectedChildWord.size) > 0;
    $("createChildSentenceBtn").disabled = !(getAdminKey() && currentSentenceId && textOk && anyIds);
  }

  function setChildWordsToggle(checked, disabled = false) {
    const el = $("childWordsToggle");
    if (!el) return;
    el.checked = !!checked;
    el.disabled = !!disabled;
  }

  async function renderChildWordsByIds(childIds) {
    const host = $("childWordsHost");
    host.innerHTML = "";
    if (!childIds.length) {
      $("childWordsMeta").textContent = "0";
      host.innerHTML = `<div class="muted tiny">none</div>`;
      return;
    }

    $("childWordsMeta").textContent = String(childIds.length);
    const list = document.createElement("ul");
    list.className = "tiny";

    const results = await Promise.all(childIds.map(async (id) => {
      try {
        return await apiGet(`/api/child_words/${id}`);
      } catch (e) {
        return { id, word: null, link: "" };
      }
    }));

    for (const r of results) {
      const li = document.createElement("li");
      if (r.word) {
        const link = r.link ? ` • <a href="${esc(r.link)}" target="_blank" rel="noopener noreferrer">link</a>` : "";
        li.innerHTML = `${esc(r.word)} <span class="muted">(#${esc(r.id)})</span>${link}`;
      } else {
        li.innerHTML = `child_word_id ${esc(r.id)}`;
      }
      list.appendChild(li);
    }

    host.appendChild(list);
  }

  function updateAutoChildEnabled() {
    $("autoChildSentenceBtn").disabled = !(getAdminKey() && currentSentenceId && !autoChildRunning);
  }

  async function clearChildSentenceDraft() {
    selectedParent = new Set();
    $("parentSelMeta").textContent = "0";
    renderParentPick();
    $("childSentenceText").value = "";
    await refreshChildPicks();
    updateCreateChildEnabled();
  }

  async function loadChildSentences() {
    if (!currentSentenceId) return;
    $("childMeta").textContent = "loading…";
    const data = await apiGet(`/api/lang_sentences/${currentSentenceId}/child_sentences`);
    const arr = Array.isArray(data.child_sentences) ? data.child_sentences : [];
    $("childMeta").textContent = `${arr.length} item(s)`;

    const host = $("childSentenceList");
    host.innerHTML = "";

    for (const cs of arr) {
      const card = document.createElement("div");
      card.className = "card";
      card.style.marginTop = "10px";
      const lw = Array.isArray(cs.lang_word_ids) ? cs.lang_word_ids : [];
      const cw = Array.isArray(cs.child_word_ids) ? cs.child_word_ids : [];
      card.innerHTML = `
        <div class="row" style="justify-content:space-between;">
          <strong>#${esc(cs.id)}</strong>
          <span class="muted tiny">updated ${esc(cs.updated_at || "")}</span>
        </div>
        <div class="mono" style="margin-top:8px;">${esc(cs.sentence || "")}</div>
        <div class="muted tiny mono" style="margin-top:8px;">lang_word_ids: ${esc(JSON.stringify(lw))} • child_word_ids: ${esc(JSON.stringify(cw))}</div>
        <div class="row" style="margin-top:8px; justify-content:flex-end;">
          <a class="tiny" href="sentence.html?child_sentence_id=${encodeURIComponent(cs.id)}">open child sentence</a>
        </div>
      `;
      host.appendChild(card);
    }

    if (!arr.length) host.innerHTML = `<div class="muted tiny">none</div>`;
  }

  async function createChildSentence() {
    if (!getAdminKey()) return alert("Admin key required.");
    if (!currentSentenceId) return;

    const text = ($("childSentenceText").value || "").trim();
    const langIds = Array.from(new Set([
      ...Array.from(selectedParent.values()),
      ...Array.from(selectedChildLang.values()),
    ])).map(Number).filter(Number.isFinite);

    const childIds = Array.from(selectedChildWord.values()).map(Number).filter(Number.isFinite);

    await apiPost(`/api/lang_sentences/${currentSentenceId}/child_sentences`, {
      lang_word_ids: langIds,
      child_word_ids: childIds,
      sentence: text
    });

    $("childSentenceText").value = "";
    await loadChildSentences();
    updateCreateChildEnabled();
  }

  async function waitForTask(taskId) {
    for (let i = 0; i < 90; i++) {
      const t = await apiGet(`/api/tasks/${taskId}`);
      $("childAutoStatus").textContent = `task ${taskId}: ${t.status}`;
      if (t.status === "done") return t;
      if (t.status === "error") throw new Error(t.error || "task failed");
      await new Promise((r) => setTimeout(r, 1500));
    }
    throw new Error("task timed out");
  }

  async function autoCreateChildSentences() {
    if (!getAdminKey()) return alert("Admin key required.");
    if (!currentSentenceId) return;
    if (autoChildRunning) return;

    autoChildRunning = true;
    updateAutoChildEnabled();
    $("childAutoStatus").textContent = "queueing…";

    try {
      const data = await apiPost(`/api/lang_sentences/${currentSentenceId}/child_sentences/auto`, {
        lang_word_ids: currentLangWordIds
      });
      const taskId = data.task_id;
      if (!taskId) throw new Error("No task id returned");
      await waitForTask(taskId);
      $("childAutoStatus").textContent = "done";
      await loadChildSentences();
    } catch (e) {
      $("childAutoStatus").textContent = "error";
      alert(String(e.message || e));
    } finally {
      autoChildRunning = false;
      updateAutoChildEnabled();
    }
  }

  async function boot() {
    await loadWordsIndex();

    updateAdminStatus();

    // picker wiring
    $("editWordsBtn").onclick = () => {
      if (!currentSentenceId) return;
      if (!getAdminKey()) return alert("Admin key required.");
      openWordPicker();
    };
    $("closeWordPickerBtn").onclick = closeWordPicker;
    $("wordPickerOverlay").addEventListener("click", (e) => {
      if (e.target === $("wordPickerOverlay")) closeWordPicker();
    });
    $("wordPickerSearch").addEventListener("input", () => renderWordPickerList());
    $("wordPickerRefreshBtn").onclick = async () => {
      await loadWordsIndex();
      renderWordPickerList();
    };
    $("closeTempWritingsBtn").onclick = closeTempWritings;
    $("refreshTempWritingsBtn").onclick = () => loadTempWritings();
    $("tempWritingsOverlay").addEventListener("click", (e) => {
      if (e.target === $("tempWritingsOverlay")) closeTempWritings();
    });

    // child sentence create wiring
    $("childSentenceText").addEventListener("input", updateCreateChildEnabled);
    $("createChildSentenceBtn").onclick = () => createChildSentence().catch(e => alert(e.message || e));
    $("clearChildSentenceBtn").onclick = () => clearChildSentenceDraft().catch(e => alert(e.message || e));
    $("autoChildSentenceBtn").onclick = () => autoCreateChildSentences().catch(e => alert(e.message || e));
    $("childWordsToggle").addEventListener("change", async () => {
      if (!currentSentenceId && !currentChildSentenceId) {
        setChildWordsToggle(false);
        return;
      }
      const enabled = $("childWordsToggle").checked;
      childWordsOnlyMode = enabled;
      setParam("child_words_only", enabled ? "1" : "");
      try {
        if (currentChildSentenceId) {
          if (enabled) await loadChildSentenceWordsOnly(currentChildSentenceId);
          else await loadChildSentence(currentChildSentenceId);
        } else if (enabled) {
          await loadChildWordsOnly(currentSentenceId);
        } else {
          await loadSentence(currentSentenceId);
        }
      } catch (e) {
        alert(e.message || e);
      }
    });

    // open sentence from query param or input
    const childOnly = getParam("child_words_only");
    childWordsOnlyMode = childOnly === "1" || childOnly === "true";
    const childQid = getParam("child_sentence_id");
    if (childQid) {
      const cid = Number(childQid);
      if (Number.isFinite(cid)) {
        if (childWordsOnlyMode) {
          try { await loadChildSentenceWordsOnly(cid); } catch (e) { console.error(e); }
        } else {
          try { await loadChildSentence(cid); } catch (e) { console.error(e); }
        }
      }
    } else {
      const qid = getParam("sentence_id");
      if (qid && childWordsOnlyMode) {
        const sid = Number(qid);
        if (Number.isFinite(sid)) {
          try { await loadChildWordsOnly(sid); } catch (e) { console.error(e); }
        }
      } else if (qid) {
        const sid = Number(qid);
        if (Number.isFinite(sid)) {
          try { await loadSentence(sid); } catch (e) { console.error(e); }
        }
      } else {
        $("metaPill").textContent = "—";
        $("sentenceMeta").textContent = "no sentence loaded";
        $("sentenceText").innerHTML = `<div class="muted tiny">open a sentence to begin</div>`;
        $("wordsHost").innerHTML = `<div class="muted tiny">no sentence loaded</div>`;
        $("wordsMeta").textContent = "—";
        $("childWordsHost").innerHTML = `<div class="muted tiny">no sentence loaded</div>`;
        $("childWordsMeta").textContent = "—";
        $("childMeta").textContent = "—";
        $("childSentenceList").innerHTML = `<div class="muted tiny">no sentence loaded</div>`;
        setChildWordsToggle(false, true);
      }
    }

    $("goBtn").onclick = async () => {
      const sid = Number(($("sentenceIdInput").value || "").trim());
      if (!Number.isFinite(sid)) return alert("Enter a valid sentence id");
      setParam("child_sentence_id", "");
      setParam("sentence_id", String(sid));
      const enabled = $("childWordsToggle").checked;
      childWordsOnlyMode = enabled;
      setParam("child_words_only", enabled ? "1" : "");
      try {
        if (enabled) await loadChildWordsOnly(sid);
        else await loadSentence(sid);
      } catch (e) {
        alert(e.message || e);
      }
    };
  }

  boot().catch(err => console.error(err));

</script>
</body>
</html>
